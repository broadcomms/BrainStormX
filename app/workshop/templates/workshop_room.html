{# app/workshop/templates/workshop_room.html (Redesigned) #}
{% extends "main_template.html" %}
{% block title %}Workshop: {{ workshop.title }}{% endblock %}

{% set is_paused = (workshop.status == 'paused') %}
{% set is_organizer_flag = (current_user.user_id == workshop.created_by_id) %}

{% block content %}
<section class="py-4 bg-body-tertiary">
  <div class="container">
    <script id="tts-defaults-json" type="application/json">
      {{ {
        'provider': (workshop.tts_provider if workshop.tts_provider is defined and workshop.tts_provider is not none else 'piper'),
        'voice': (workshop.tts_voice if workshop.tts_voice is defined and workshop.tts_voice is not none else ''),
        'speed': (workshop.tts_speed_default if workshop.tts_speed_default is defined and workshop.tts_speed_default is not none else 1.0),
        'autoread': (workshop.tts_autoread_enabled if workshop.tts_autoread_enabled is defined and workshop.tts_autoread_enabled is not none else true),
        'workshop_id': workshop.id
      } | tojson }}
    </script>
    <!-- Developer: LLM schema examples for error banners (safe static examples) -->
    <script id="llm-schema-examples" type="application/json">
      {{ {
        'prioritization': {
          'prioritized': [
            { 'id': 101, 'title': 'Idea A', 'score': 0.87, 'cluster_id': 12, 'votes_norm': 0.6, 'scores': { 'impact': 80, 'effort': 40 } },
            { 'id': 205, 'title': 'Idea B', 'score': 0.72, 'cluster_id': 15, 'votes_norm': 0.5, 'scores': { 'impact': 70, 'effort': 50 } }
          ],
          'rationale': 'We chose ideas with high expected impact and manageable effort based on workshop signals.',
          'tts_script': 'Here is our prioritized shortlist and why we selected these items...'
        },
        'action_plan': {
          'action_items': [
            { 'title': 'Set up pilot', 'description': 'Configure a limited-scope pilot environment.', 'owner_participant_id': none, 'status': 'todo', 'due_date': '2025-10-15', 'priority': 1 },
            { 'title': 'Gather feedback', 'description': 'Collect qualitative feedback from pilot users.', 'owner_participant_id': none, 'status': 'todo', 'due_date': '2025-11-01', 'priority': 2 }
          ],
          'milestones': [
            { 'title': 'Pilot ready', 'index': 1, 'item_indices': [1] },
            { 'title': 'Feedback & decision', 'index': 2, 'item_indices': [2] }
          ],
          'tts_script': 'Next, we will execute the following plan with key milestones...'
        }
      } | tojson }}
    </script>
    <!-- Breadcrumbs -->
    <nav aria-label="breadcrumb" class="mb-3">
      <ol class="breadcrumb mb-0 small">
        <li class="breadcrumb-item"><a href="{{ url_for('main_bp.index') }}">Home</a></li>
        <li class="breadcrumb-item"><a href="{{ url_for('workshop_bp.list_workshops') }}">Workshops</a></li>
        <li class="breadcrumb-item"><a href="{{ url_for('workshop_bp.view_workshop', workshop_id=workshop.id) }}">Details</a></li>
        <li class="breadcrumb-item active" aria-current="page">Live Session</li>
      </ol>
    </nav>

    <!-- Header / Status / Controls -->
    <div class="card shadow-sm border-0 mb-4">
      <div class="card-body d-flex flex-column flex-xl-row align-items-xl-center gap-3">
        <div class="flex-grow-1">
          <h1 class="h4 fw-bold mb-2 d-flex align-items-center gap-2 text-truncate" title="{{ workshop.title }}">
            <i class="bi bi-easel2"></i><span>{{ workshop.title }}</span>
            <span id="workshop-status-badge" class="badge {{ 'bg-warning text-dark' if is_paused else 'bg-success' }}">{{ workshop.status|capitalize }}</span>
          </h1>
          <div class="small text-body-secondary">Hosted by {{ workshop.creator.first_name or workshop.creator.email }}</div>
        </div>
        <!-- Timer -->
        <div class="text-center text-xl-end">
          <div id="timer-display">
            <div class="fw-semibold font-monospace fs-3" id="timer-text">00:00</div>
            <div class="progress progress-thin">
              <div id="progress-bar" class="progress-bar progress-bar-initial" role="progressbar" aria-label="Task progress"></div>
            </div>
          </div>
        </div>
        <!-- Controls -->
        <div class="d-flex flex-wrap gap-2 justify-content-start justify-content-xl-end align-items-center">
          <a id="leave-room-btn" data-leave-url="{{ url_for('workshop_bp.view_workshop', workshop_id=workshop.id) }}" class="btn btn-outline-secondary btn-sm"><i class="bi bi-box-arrow-left"></i> Leave</a>
          {% if is_organizer_flag %}
            {% if workshop.status == 'inprogress' %}
              <form id="pause-workshop-form-room" method="POST" action="{{ url_for('workshop_bp.pause_workshop', workshop_id=workshop.id) }}"><button class="btn btn-warning btn-sm" type="submit"><i class="bi bi-pause-fill"></i> Pause</button></form>
            {% elif workshop.status == 'paused' %}
              <form id="resume-workshop-form-room" method="POST" action="{{ url_for('workshop_bp.resume_workshop', workshop_id=workshop.id) }}"><button class="btn btn-success btn-sm" type="submit"><i class="bi bi-play-fill"></i> Resume</button></form>
            {% endif %}
            {% if workshop.status in ['inprogress','paused'] %}
              <form id="stop-workshop-form-room" method="POST" action="{{ url_for('workshop_bp.stop_workshop', workshop_id=workshop.id) }}" onsubmit="return confirm('Stop this workshop?');"><button class="btn btn-danger btn-sm" type="submit"><i class="bi bi-stop-fill"></i> Stop</button></form>
            {% endif %}
            <form id="begin-intro-form" action="{{ url_for('workshop_bp.begin_intro', workshop_id=workshop.id) }}" method="POST" class="d-inline {{ 'd-none' if workshop.status!='inprogress' else '' }}">
              <button type="submit" class="btn btn-info btn-sm"><i class="bi bi-play-circle"></i> Begin Workshop</button>
            </form>
            <!-- Organizer navigation controls (always visible; enabled when a task is active) -->
            <button id="prev-task-btn" class="btn btn-outline-secondary btn-sm" type="button" title="Go to previous phase" disabled><i class="bi bi-arrow-left-circle"></i> Prev</button>
            <button id="end-task-btn" class="btn btn-outline-danger btn-sm" type="button" title="End the current phase immediately" disabled><i class="bi bi-flag-fill"></i> End</button>
            <button id="next-task-btn" class="btn btn-secondary btn-sm" disabled><i class="bi bi-arrow-right-circle"></i> Next Task</button>
            <!-- Organizer auto-advance controls -->
            <div class="form-check form-switch ms-2 d-flex align-items-center gap-2" title="Auto-advance to the next task after a short delay when time ends">
              <input class="form-check-input" type="checkbox" role="switch" id="auto-advance-switch">
              <label class="form-check-label small" for="auto-advance-switch">Auto-advance</label>
              <input type="number" id="auto-advance-seconds" class="form-control form-control-sm w-70px" min="0" step="1" placeholder="sec">
            </div>
          {% endif %}
          <div id="user-dots-display" class="d-none"><span class="badge text-bg-light">Dots: <span id="user-dots-count">0</span></span></div>
        </div>
      </div>
  <!-- Removed: compact participant strip to declutter the top; moved to right-side Participants tab -->
    </div>

    <!-- Main Grid -->
    <div class="row g-4">
      <!-- LEFT: AI Facilitator & Dynamic Task Areas -->
      <div class="col-12 col-lg-7 d-flex flex-column gap-4">

        <!-- Video Conference Section (gated by conference_active) -->
        {% if workshop.conference_active %}
        <div id="video-conference-card" class="card shadow-sm border-0">
    <div class="card-header bg-transparent py-3 d-flex flex-wrap align-items-center justify-content-between gap-2">
            <div class="d-flex align-items-center gap-2">
              <i class="bi bi-camera-video text-danger"></i>
              <span class="fw-semibold">Video Conference</span>
              <span id="vc-reconnect-badge" class="badge bg-warning text-dark d-none">Reconnecting…</span>
            </div>
            <div class="d-flex align-items-center gap-2 flex-wrap" id="vc-control-bar">
              <button id="vc-btn-mic" class="btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" data-bs-title="Toggle Microphone" aria-label="Toggle Microphone"><i class="bi bi-mic-fill"></i></button>
              <button id="vc-btn-cam" class="btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" data-bs-title="Toggle Camera" aria-label="Toggle Camera"><i class="bi bi-camera-video-fill"></i></button>
              <button id="vc-btn-share" class="btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" data-bs-title="Share Screen" aria-label="Share Screen"><i class="bi bi-display"></i></button>
              <button id="vc-btn-cc" class="btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" data-bs-title="Live Captions" aria-label="Live Captions"><i class="bi bi-type"></i></button>
              <button id="vc-btn-leave" class="btn btn-sm btn-outline-danger" data-bs-toggle="tooltip" data-bs-title="Leave Conference" aria-label="Leave Conference"><i class="bi bi-box-arrow-right"></i></button>
              <!-- Standalone conference view deprecated; fullscreen link removed -->
            </div>
          </div>
          <div class="card-body">
            <div id="vc-permission-warning" class="alert alert-warning d-none py-2 px-3 small mb-2"><i class="bi bi-exclamation-triangle-fill me-1"></i><span id="vc-permission-text">Camera/Microphone access was blocked. Please allow permissions and retry.</span> <button id="vc-retry-permissions" class="btn btn-sm btn-outline-secondary ms-2">Retry</button></div>
            <div id="vc-status-line" class="small text-muted mb-2">Not connected</div>
            <div id="video-grid" class="vc-grid">
              <!-- Local/remote video tiles injected here by videoConference.js -->
              <div id="video-placeholder" class="text-muted small fst-italic p-3">Video conference will appear here once started.</div>
            </div>
          </div>
        </div>

        {% elif workshop.transcription_enabled %}
        <!-- Transcription-only mode (conference disabled) -->
        <div class="card shadow-sm border-0" id="transcription-only-banner">
          <div class="card-body py-3 d-flex justify-content-between align-items-center">
            <div class="d-flex flex-column gap-1">
              <span class="fw-semibold d-flex align-items-center gap-2"><i class="bi bi-type"></i> Live Transcription <span id="transcription-recording-badge" class="badge text-bg-danger d-none transcript-recording-badge"><i class="bi bi-record-fill"></i> Recording</span></span>
              <small class="text-body-secondary">Video conference is disabled. Enable/disable captions below. Auto-start preference is remembered per browser.</small>
            </div>
            <div>
              <div class="d-flex flex-column gap-2 align-items-end">
                <button id="standalone-cc-toggle" class="btn btn-sm btn-outline-primary"><i class="bi bi-cc-square"></i> Start Captions</button>
                <div class="form-check form-switch small">
                  <input class="form-check-input" type="checkbox" id="stt-auto-start-pref">
                  <label class="form-check-label" for="stt-auto-start-pref">Auto-start next time</label>
                </div>
              </div>
            </div>
          </div>
        </div>
        {% endif %}

        <!-- AI Facilitator (moved below Video Conference / Transcription banner) -->
        <div class="card shadow-sm border-0 mb-0">
          <div class="card-header bg-transparent d-flex align-items-center justify-content-between py-3">
            <div class="d-flex align-items-center gap-2"><i class="bi bi-robot text-primary"></i><span class="fw-semibold">AI Facilitator</span></div>
            <span class="badge rounded-pill text-bg-secondary" id="current-phase-label">Phases</span>
          </div>
          <div class="card-body position-relative min-h-160" id="task-area">
            <p id="task-placeholder" class="text-body-secondary">Waiting for the workshop task to begin...</p>
            <div id="warmup-confirm-banner" class="alert alert-success alert-dismissible fade d-none warmup-confirmation" role="status">
              <div class="d-flex align-items-start gap-3">
                <i class="bi bi-stars fs-4 text-warning"></i>
                <div class="flex-grow-1">
                  <div class="fw-semibold">Warm-up locked in</div>
                  <div id="warmup-confirm-summary" class="small fw-semibold"></div>
                  <div id="warmup-handoff-phrase" class="small mt-1"></div>
                  <div id="warmup-next-phase-hint" class="small text-muted mt-1"></div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Dismiss"></button>
              </div>
            </div>
            <div id="task-content" class="d-none">
              <h5 id="task-title" class="mb-2"></h5>
              <div id="task-body" class="small"></div>
              <div class="mt-2 d-flex flex-wrap align-items-center gap-2">
                <div class="small text-body-secondary" id="tts-defaults-display" title="Reading uses workshop TTS settings"></div>
              </div>
              <!-- Facilitator Voice Controls (advanced UI across phases) -->
              <div id="fac-tts-container" class="mt-3">
                <div class="d-flex align-items-center gap-3 flex-wrap">
                  <div id="facilitator-voice-icon" class="facilitator-voice-icon" aria-label="Speaking indicator" title="Speaking indicator"></div>
                  <div class="btn-group" role="group" aria-label="Facilitator voice controls">
                    <button class="btn btn-sm btn-primary" id="fac-tts-play" type="button" title="Play">
                      <i class="bi bi-play-fill"></i>
                    </button>
                    <button class="btn btn-sm btn-secondary" id="fac-tts-pause" type="button" title="Pause">
                      <i class="bi bi-pause-fill"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" id="fac-tts-stop" type="button" title="Stop">
                      <i class="bi bi-stop-fill"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-primary" id="fac-tts-replay" type="button" title="Replay (from start)" aria-label="Replay from start">
                      <i class="bi bi-arrow-repeat"></i>
                    </button>
                  </div>
                  <div class="flex-grow-1 fac-tts-progress-container">
                    <div class="progress progress-thin" id="fac-tts-progress-container" title="Click to seek">
                      <div id="fac-tts-progress" class="progress-bar" role="progressbar" aria-label="Playback progress"></div>
                    </div>
                    <div class="d-flex justify-content-between small text-muted mt-1">
                      <span id="fac-tts-elapsed">00:00</span>
                      <span id="fac-tts-duration">--:--</span>
                    </div>
                  </div>
                  <!-- Settings Popover -->
                  <div class="dropdown">
                    <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" title="Voice settings">
                      <i class="bi bi-gear"></i>
                    </button>
                    <div class="dropdown-menu p-3 fac-tts-settings-menu">
                      <div class="mb-2">
                        <label class="form-label small">Provider</label>
                        <select class="form-select form-select-sm" id="fac-tts-provider" aria-label="TTS provider">
                          <option value="piper">Piper (local)</option>
                          <option value="polly">Amazon Polly</option>
                        </select>
                      </div>
                      <div class="mb-2">
                        <label class="form-label small">Voice</label>
                        <input type="text" class="form-control form-control-sm" id="fac-tts-voice" placeholder="e.g., en_US-amy" aria-label="TTS voice">
                      </div>
                      <div class="mb-2">
                        <label class="form-label small">Speed</label>
                        <input type="number" step="0.1" min="0.5" max="2.0" class="form-control form-control-sm" id="fac-tts-speed" placeholder="1.0" aria-label="TTS speed">
                      </div>
                      <div class="d-flex justify-content-end gap-2">
                        <button class="btn btn-sm btn-outline-secondary" id="fac-tts-cancel">Cancel</button>
                        <button class="btn btn-sm btn-primary" id="fac-tts-save">Save</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              
            </div>
            <div id="pause-overlay" class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50 d-flex justify-content-center align-items-center overlay-z-10 {{ '' if is_paused else 'd-none' }}">
              <span class="fs-5 text-white d-inline-flex align-items-center gap-2"><i class="bi bi-pause-circle-fill"></i>Paused</span>
            </div>
          </div>
          <div class="card-footer small bg-body-tertiary text-body-secondary">Guided workshop activities progress automatically, use the whiteboard or chat to collaborate.</div>
        </div>





      </div>

      <!-- RIGHT: Participants / Chat / Phase Map -->
      <div class="col-12 col-lg-5 d-flex flex-column gap-4">
        <!-- Transcript / Chat / Participants Tabs -->
        <div class="card shadow-sm border-0" id="right-tabs-card">
          <div class="card-header bg-transparent py-3 d-flex justify-content-between align-items-center pt-3">
            <ul class="nav nav-tabs card-header-tabs" id="rightTabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="transcript-tab" data-bs-toggle="tab" data-bs-target="#transcript-pane" type="button" role="tab" aria-controls="transcript-pane" aria-selected="true"><i class="bi bi-cc-square"></i> Transcript</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="chat-tab" data-bs-toggle="tab" data-bs-target="#chat-pane" type="button" role="tab" aria-controls="chat-pane" aria-selected="false"><i class="bi bi-chat-dots"></i> Chat</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="participants-tab" data-bs-toggle="tab" data-bs-target="#participants-pane" type="button" role="tab" aria-controls="participants-pane" aria-selected="false"><i class="bi bi-people"></i> Participants</button>
              </li>
            </ul>
          </div>
          <!-- Make card-body the tab container and prevent hidden panes from affecting layout -->
          <div class="card-body p-0 tab-content overflow-hidden">
            <!-- Transcript Pane (now default active) -->
            <div class="tab-pane fade show active" id="transcript-pane" role="tabpanel" aria-labelledby="transcript-tab">
              <!-- Flex viewport: grows until a reasonable height then scrolls -->
              <div class="d-flex flex-column pane-viewport">
                <div id="transcript-list" class="small flex-grow-1 overflow-auto px-3 py-3 border-bottom transcript-list-scroll">
                  <p class="text-muted fst-italic mb-0" id="transcript-empty-placeholder">Live transcripts will appear here...</p>
                </div>
                <div class="p-2 small text-body-secondary d-flex justify-content-between align-items-center">
                  <span class="d-flex align-items-center gap-2"><span id="transcript-status" class="text-muted">CC: Off</span><span id="transcript-recording-badge-inline" class="badge text-bg-danger d-none transcript-recording-badge"><i class="bi bi-record-fill"></i> Recording</span></span>
                  <div class="d-flex align-items-center gap-2">
                    <button id="transcript-scroll-bottom" type="button" class="btn btn-link btn-sm p-0 d-none">Scroll to latest</button>
                    <div class="btn-group">
                      <button id="btn-tts-read-transcript" type="button" class="btn btn-sm btn-outline-secondary"><i class="bi bi-volume-up"></i> Read Aloud</button>
                      <button id="btn-tts-stop-transcript" type="button" class="btn btn-sm btn-outline-danger" title="Stop reading"><i class="bi bi-stop-fill"></i></button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <!-- Chat Pane (second) -->
            <div class="tab-pane fade" id="chat-pane" role="tabpanel" aria-labelledby="chat-tab">
              <div class="d-flex flex-column pane-viewport">
                <div class="d-flex align-items-center justify-content-between px-3 pt-2 small gap-2">
                  <label for="chat-scope" class="text-muted mb-0">Scope</label>
                  <select id="chat-scope" class="form-select form-select-sm w-auto" title="Choose chat scope">
                    <option value="workshop_chat">Workshop</option>
                    <option value="discussion_chat">Discussion</option>
                  </select>
                </div>
                <div id="chat-messages" class="small flex-grow-1 overflow-auto px-3 py-2 border-bottom chat-messages"></div>
                <form id="chat-form" class="p-3 pt-2 border-0 flex-shrink-0">
                  <div class="input-group input-group-sm">
                    <input id="chat-input" type="text" class="form-control" placeholder="Type message…" autocomplete="off" aria-label="Chat input">
                    <button class="btn btn-outline-primary" type="submit" aria-label="Send message"><i class="bi bi-send"></i></button>
                  </div>
                </form>
              </div>
            </div>
            <!-- Participants Pane (third) -->
            <div class="tab-pane fade" id="participants-pane" role="tabpanel" aria-labelledby="participants-tab">
              <div class="d-flex flex-column pane-viewport">
                <div class="list-group list-group-flush small flex-grow-1 overflow-auto" id="participants-list" data-profile-url-template="{{ url_for('account_bp.public_profile', user_id=0) }}"></div>
                <div class="p-2 small text-body-secondary d-flex justify-content-between align-items-center border-top flex-shrink-0">
                  <span id="participants-count" class="text-muted">0 participants</span>
                  {% if is_organizer_flag %}
                  <a class="btn btn-sm btn-outline-primary" href="{{ url_for('workshop_bp.view_workshop', workshop_id=workshop.id) }}#participants" title="Manage participants"><i class="bi bi-people"></i> Manage</a>
                  {% endif %}
                </div>
              </div>
            </div>
          </div>
          <div class="card-footer small bg-body-tertiary text-body-secondary">Transcript, chat, and participants update live.</div>
        </div>


      </div>





















  </div>
    
    <!-- Session Flow moved below AI Facilitator -->
  <div class="card shadow-sm border-0 mt-4 mb-4">
      <div class="card-header bg-transparent py-3 d-flex align-items-center justify-content-between gap-2">
        <div class="d-flex align-items-center gap-2">
          <i class="bi bi-map text-warning"></i><span class="fw-semibold">Session Flow</span>
        </div>
        <span id="session-flow-timer" class="badge rounded-pill text-bg-light font-monospace" aria-live="polite">00:00</span>
      </div>
      <div class="card-body small">
        <div id="session-flow" class="d-flex flex-wrap gap-2 justify-content-center" aria-label="Phases"></div>
      </div>
  </div>

    <!-- Collaboration Panel Grid (Whiteboard / Clusters / Reports) -->
  <div class="card shadow-sm border-0 mt-3">
      <div class="card-header bg-transparent py-3 d-flex align-items-center gap-2">
        <i class="bi bi-columns-gap text-success"></i><span id="left-column-title" class="fw-semibold">Whiteboard</span>
      </div>
      <div class="card-body">
        {% if is_organizer_flag %}
        <div id="ai-idea-controls" class="d-flex flex-wrap align-items-center justify-content-between gap-2 mb-3">
          <div class="form-check form-switch small mb-0">
            <input class="form-check-input" type="checkbox" id="ai-idea-include-switch">
            <label class="form-check-label" for="ai-idea-include-switch">Include AI ideas in reports</label>
          </div>
          <div id="ai-idea-include-hint" class="small text-body-secondary">AI facilitator ideas feed into clustering, reports, and exports.</div>
        </div>
        {% endif %}
        <div id="ai-idea-include-banner" class="alert alert-warning-subtle border-start border-4 border-warning small d-none mb-3" role="status">
          <i class="bi bi-slash-circle me-1"></i>AI facilitator ideas are currently excluded from downstream reports and exports.
        </div>
        <!-- Screen Share Stage (appears above all collaboration widgets) -->
        <div id="screen-stage" class="screen-stage d-none" aria-live="polite" aria-label="Screen Share Stage">
          <div class="screen-stage-header d-flex align-items-center justify-content-between small">
            <div class="d-flex align-items-center gap-2">
              <i class="bi bi-display"></i>
              <span class="fw-semibold">Screen Share</span>
              <span id="screen-stage-owner" class="badge text-bg-secondary ms-1"></span>
            </div>
            <span id="screen-stage-hint" class="text-body-secondary">Press the Screen button again to stop sharing.</span>
          </div>
          <div class="screen-stage-body position-relative">
            <div class="screen-stage-placeholder text-body-secondary small">Screen share will appear here…</div>
            <video id="screen-stage-video" autoplay muted class="w-100 h-100 object-fit-contain rounded"></video>
          </div>
        </div>
        <!-- Idea Whiteboard -->
        <div id="sticky-board" class="d-flex flex-wrap gap-2 border rounded p-2 mb-3 bg-body-tertiary min-h-220 d-none">
          <p id="idea-placeholder" class="text-body-secondary small fst-italic w-100 text-center mt-3">Ideas will appear here...</p>
        </div>
        <!-- Cluster Voting -->
        <div id="cluster-voting-area" class="mb-3 d-none"></div>
        <!-- Generic Voting -->
        <div id="generic-voting-area" class="mb-3 d-none"></div>
        <!-- Report (Feasibility / Summary) -->
        <div id="report-area" class="border rounded p-3 bg-body-tertiary mb-3 d-none"></div>
        <!-- Discussion Forum (replaces legacy Discussion box during Discussion phase) -->
        <div id="discussion-forum-section" class="mb-3 d-none">

          <div class="border rounded bg-body-tertiary p-3 d-flex flex-column gap-3 min-h-160" id="discussion-panel" aria-live="polite">
            {% if is_organizer_flag %}
            <section id="discussion-facilitator-controls" class="discussion-section">
              <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                <h6 class="text-uppercase small fw-semibold mb-0 text-body-secondary">Facilitator Controls</h6>
                <span id="discussion-run-status" class="badge text-bg-light d-none"></span>
              </div>
              <div class="d-grid gap-2 mt-2" id="discussion-control-buttons">
                <button type="button" class="btn btn-sm btn-primary discussion-action-btn" data-action="run">
                  <i class="bi bi-rocket-takeoff"></i> Launch AI Discussion
                </button>
                <button type="button" class="btn btn-sm btn-outline-primary discussion-action-btn" data-action="mediator">
                  <i class="bi bi-people"></i> Mediator Prompt
                </button>
                <button type="button" class="btn btn-sm btn-outline-danger discussion-action-btn" data-action="devil-advocate">
                  <i class="bi bi-lightning"></i> Devil's Advocate
                </button>
                <button type="button" class="btn btn-sm btn-outline-secondary discussion-action-btn" data-action="scribe">
                  <i class="bi bi-journal-check"></i> Scribe Summary
                </button>
                <button type="button" class="btn btn-sm btn-outline-secondary discussion-action-btn" data-action="forum-seed">
                  <i class="bi bi-diagram-3"></i> Seed Forum Now
                </button>
              </div>
            </section>
            {% endif %}

            <section class="discussion-section" id="discussion-overview-block">
              <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                <h6 class="text-uppercase small fw-semibold mb-0 text-body-secondary">Discussion Overview</h6>
                <small id="discussion-updated-at" class="text-body-secondary"></small>
              </div>
              <div id="discussion-narration" class="mt-2 text-body-secondary fst-italic">AI discussion prep will appear here once generated.</div>
            </section>

            <section class="discussion-section" id="discussion-decisions-block">
              <h6 class="text-uppercase small fw-semibold mb-1 text-body-secondary">Captured Decisions</h6>
              <div id="discussion-decision-list" class="discussion-card border rounded px-2 py-2 bg-body-tertiary">No AI decisions captured yet.</div>
            </section>

            <section class="discussion-section" id="discussion-notes-block">
              <h6 class="text-uppercase small fw-semibold mb-1 text-body-secondary">Highlights &amp; Notes</h6>
              <div id="discussion-note-list" class="discussion-card border rounded px-2 py-2 bg-body-tertiary">No AI notes captured yet.</div>
            </section>

            <section class="discussion-section" id="discussion-devil-block">
              <h6 class="text-uppercase small fw-semibold mb-1 text-body-secondary">Devil's Advocate</h6>
              <ul id="discussion-devil-advocate" class="discussion-card border rounded px-2 py-2 bg-body-tertiary ">No challenges queued yet.</ul>
            </section>

            <section class="discussion-section" id="discussion-mediator-block">
              <h6 class="text-uppercase small fw-semibold mb-1 text-body-secondary">Mediator Prompt</h6>
              <div id="discussion-mediator-prompt" class="discussion-card border rounded px-2 py-2 bg-body-tertiary">Mediator suggestions will appear here.</div>
            </section>

            <section class="discussion-section" id="discussion-scribe-block">
              <h6 class="text-uppercase small fw-semibold mb-1 text-body-secondary">Scribe Summary</h6>
              <div id="discussion-scribe-summary" class="discussion-card border rounded px-2 py-2 bg-body-tertiary">No scribe summary captured yet.</div>
            </section>

            <section class="discussion-section" id="discussion-action-block">
              <h6 class="text-uppercase small fw-semibold mb-1 text-body-secondary">Action Items</h6>
              <div id="discussion-action-list" class="discussion-card border rounded px-2 py-2 bg-body-tertiary">No follow-up actions available.</div>
            </section>
          </div>

          <div class="border rounded bg-body-tertiary p-3 d-flex flex-column gap-3 mt-3 min-h-160" id="forum-panel" aria-live="polite">
            <div class="d-flex align-items-center gap-2 mb-2">
              <i class="bi bi-journal-text text-info"></i>
              <span class="fw-semibold">Forum</span>
              {% if is_organizer_flag %}
              <button id="forum-seed-btn" class="btn btn-sm btn-outline-secondary ms-auto" title="Seed from clusters & ideas">Seed</button>
              {% endif %}
            </div>


            <div class="row g-3">
              <div id="discussion-forum-root" class="border rounded small min-h-160"></div>
            </div>

            <div class="row g-3">
              <div id="discussion-forum-right" class="border rounded min-h-160"></div>
            </div>



          </div>

        </div>
        <!-- Idea Input -->
        <div id="idea-form-container" class="d-none">
          <form id="idea-form">
            <label for="idea-input" class="form-label small text-body-secondary mb-1">Your Idea / Response</label>
            <textarea id="idea-input" class="form-control mb-2" rows="2" placeholder="Share your idea…" autocomplete="off" required></textarea>
            <button id="idea-submit" type="submit" class="btn btn-primary w-100"><i class="bi bi-send"></i> Submit</button>
          </form>
        </div>
      </div>
      <div class="card-footer small bg-body-tertiary text-body-secondary">Whiteboard & generated content refresh live for all participants.</div>
  </div>




  </div>
</section>

<!-- Toast / Notification area -->
<div id="notification-area" class="position-fixed top-0 start-50 translate-middle-x mt-3 px-3 notification-area notif-area"></div>


<script src="{{ url_for('static', filename='js/warm_up.js') }}"></script>
<script>
  // --- Global State ---
  let currentTaskId = JSON.parse('{{ workshop.current_task_id | default(none) | tojson | safe }}');
  let currentTaskType = null; // Will be set by task events
  let currentTaskIndex = null; // Index in the current plan, provided by payload
  let countdownInterval = null;
  let totalDurationForCurrentTask = 0; // MUST be updated when a task starts
  let userDots = 0; // Track user's dots locally
  let userVotes = {}; // Track which clusters user voted for { clusterId: true }
  let genericUserVotes = {}; // Track generic item votes { 'type:id': true }

  // Auto-advance config (server-driven)
  let autoAdvanceEnabled = JSON.parse('{{ workshop.auto_advance_enabled | tojson | safe }}');
  let autoAdvanceDelaySeconds = JSON.parse('{{ workshop.auto_advance_after_seconds | tojson | safe }}');
  if (autoAdvanceDelaySeconds == null) { autoAdvanceDelaySeconds = 0; }
  let autoAdvanceTimeout = null;

  const workshopId = JSON.parse('{{ workshop.id | tojson | safe }}');
  // Expose globally for consumers that check window.workshopId
  window.workshopId = workshopId;
  const userId = JSON.parse('{{ current_user.user_id | tojson | safe }}');
  const isOrganizer = JSON.parse('{{ is_organizer_flag | tojson | safe }}');
  const participantDeleteEnabled = JSON.parse('{{ workshop.participant_can_delete_transcripts | tojson | safe }}');
  // Expose to window so embedded modules (forum.js) can detect organizer controls
  try {
    window.isOrganizer = isOrganizer;
    window.userId = userId;
    window.participantDeleteEnabled = participantDeleteEnabled;
  } catch (_) {}
  const roomName = `workshop_room_${workshopId}`;
  let workshopStatus = '{{ workshop.status }}'; // Initial status from server

  // Plan cache for dynamic session flow rendering
  let planCache = null; // { current_plan: [ {task_type, duration, ...} ] }
  let warmupHydrationApplied = false;
  let aiIdeaIncludeState = true;
  let aiIdeaToggleInFlight = false;

  // --- DOM Elements (ensure all IDs match HTML) ---
  const elements = {
    taskArea: document.getElementById('task-area'),
    taskPlaceholder: document.getElementById('task-placeholder'),
    taskContent: document.getElementById('task-content'),
    taskTitle: document.getElementById('task-title'),
    // taskDescription: document.getElementById('task-description'),
    taskBody: document.getElementById('task-body'), // Container for dynamic content

    ideaFormContainer: document.getElementById('idea-form-container'),
    ideaInput: document.getElementById('idea-input'),
    ideaSubmitBtn: document.getElementById('idea-submit'),
    ideaForm: document.getElementById('idea-form'),
    stickyBoard: document.getElementById('sticky-board'),
    ideaPlaceholder: document.getElementById('idea-placeholder'),
  aiIdeaControls: document.getElementById('ai-idea-controls'),
  aiIdeaIncludeSwitch: document.getElementById('ai-idea-include-switch'),
  aiIdeaIncludeHint: document.getElementById('ai-idea-include-hint'),
  aiIdeaIncludeBanner: document.getElementById('ai-idea-include-banner'),

    clusterVotingArea: document.getElementById('cluster-voting-area'),
  genericVotingArea: document.getElementById('generic-voting-area'),
    reportArea: document.getElementById('report-area'),
    leftColumnTitle: document.getElementById('left-column-title'),


    progressBar: document.getElementById('progress-bar'),
    timerText: document.getElementById('timer-text'),
  sessionFlowTimer: document.getElementById('session-flow-timer'),
    chatForm: document.getElementById('chat-form'),
    chatInput: document.getElementById('chat-input'),
  chatMessages: document.getElementById('chat-messages'),
  chatScope: document.getElementById('chat-scope'),
  participantsList: document.getElementById('participants-list'),
  participantsCount: document.getElementById('participants-count'),
    beginIntroForm: document.getElementById('begin-intro-form'),
    nextTaskBtn: document.getElementById('next-task-btn'),
  prevTaskBtn: document.getElementById('prev-task-btn'),
  endTaskBtn: document.getElementById('end-task-btn'),
    pauseOverlay: document.getElementById('pause-overlay'),
    statusBadge: document.getElementById('workshop-status-badge'),
    leaveRoomBtn: document.getElementById('leave-room-btn'),
    pauseWorkshopForm: document.getElementById('pause-workshop-form-room'),
    resumeWorkshopForm: document.getElementById('resume-workshop-form-room'),
    stopWorkshopForm: document.getElementById('stop-workshop-form-room'),

    userDotsDisplay: document.getElementById('user-dots-display'),
  userDotsCount: document.getElementById('user-dots-count'),
  sessionFlow: document.getElementById('session-flow'),

  discussionPanel: document.getElementById('discussion-panel'),
  discussionRunStatus: document.getElementById('discussion-run-status'),
  discussionUpdatedAt: document.getElementById('discussion-updated-at'),
  discussionNarration: document.getElementById('discussion-narration'),
  discussionDecisionList: document.getElementById('discussion-decision-list'),
  discussionNoteList: document.getElementById('discussion-note-list'),
  discussionDevilAdvocate: document.getElementById('discussion-devil-advocate'),
  discussionMediatorPrompt: document.getElementById('discussion-mediator-prompt'),
  discussionScribeSummary: document.getElementById('discussion-scribe-summary'),
  discussionActionList: document.getElementById('discussion-action-list'),
  discussionDecisionsBlock: document.getElementById('discussion-decisions-block'),
  discussionNotesBlock: document.getElementById('discussion-notes-block'),
  discussionDevilBlock: document.getElementById('discussion-devil-block'),
  discussionMediatorBlock: document.getElementById('discussion-mediator-block'),
  discussionScribeBlock: document.getElementById('discussion-scribe-block'),
  discussionActionBlock: document.getElementById('discussion-action-block')

  };

  const FACILITATOR_ROLE_KEYS = new Set(['organizer', 'facilitator', 'admin']);
  const ROLE_BADGE_META = Object.freeze({
    organizer: { label: 'Organizer', className: 'badge text-bg-primary', impliesFacilitator: true },
    facilitator: { label: 'Facilitator', className: 'badge text-bg-warning-subtle text-warning-emphasis', impliesFacilitator: true },
    admin: { label: 'Admin', className: 'badge text-bg-dark', impliesFacilitator: true },
    participant: { label: 'Participant', className: 'badge text-bg-info-subtle text-info-emphasis', impliesFacilitator: false },
    guest: { label: 'Guest', className: 'badge text-bg-secondary', impliesFacilitator: false }
  });

  // Parse TTS defaults ASAP so FacilitatorTTS can honor autoread on initial load
  try {
    const ttsDefaultsEl = document.getElementById('tts-defaults-json');
    if (ttsDefaultsEl && !window.ttsDefaults) {
      window.ttsDefaults = JSON.parse(ttsDefaultsEl.textContent || '{}');
    }
  } catch (_) { /* no-op */ }

  // --- Small helpers to toggle visibility with Bootstrap d-none ---
  const show = (el) => { if (!el) return; el.classList.remove('d-none'); el.style.removeProperty('display'); };
  const hide = (el) => { if (!el) return; el.classList.add('d-none'); };

  // Tooltip helper: set/update tooltip title robustly
  function setTooltip(el, title) {
    if (!el) return;
    try {
      el.setAttribute('title', title);
      el.setAttribute('data-bs-title', title);
      const inst = bootstrap.Tooltip.getInstance(el) || bootstrap.Tooltip.getOrCreateInstance(el);
      if (inst && typeof inst.setContent === 'function') {
        inst.setContent({ '.tooltip-inner': title });
      } else {
        // Fallback for older Bootstrap: recreate to refresh content
        if (inst && typeof inst.dispose === 'function') inst.dispose();
        bootstrap.Tooltip.getOrCreateInstance(el);
      }
    } catch (_) { /* noop */ }
  }

  const escapeHtml = (value) => {
    if (value === null || value === undefined) {
      return '';
    }
    return String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  };

  const discussionState = {
    payload: null,
    narration: '',
    decisions: [],
    notes: [],
    devilAdvocate: [],
    mediatorPrompt: '',
    scribeSummary: '',
    actionItems: [],
    updatedAt: null,
  };

  const DISCUSSION_ACTION_ENDPOINTS = {
    run: 'discussion/run',
    mediator: 'discussion/mediator',
    'devil-advocate': 'discussion/devil-advocate',
    scribe: 'discussion/scribe',
    'forum-seed': 'discussion/forum-seed',
  };

  const DISCUSSION_ACTION_LABELS = {
    run: 'Launching AI discussion…',
    mediator: 'Requesting mediator prompt…',
    'devil-advocate': "Challenging with devil's advocate…",
    scribe: 'Drafting scribe summary…',
    'forum-seed': 'Seeding forum…',
  };

  const DISCUSSION_SUCCESS_LABELS = {
    run: 'Discussion plan ready',
    mediator: 'Mediator prompt ready',
    'devil-advocate': 'Devil’s advocate queued',
    scribe: 'Scribe summary ready',
    'forum-seed': 'Forum seeded',
  };

  function setDiscussionRunStatus(message, variant = 'light') {
    const badge = elements.discussionRunStatus;
    if (!badge) return;
    if (!message) {
      badge.classList.add('d-none');
      badge.textContent = '';
      badge.className = 'badge text-bg-light d-none';
      return;
    }
    badge.className = `badge text-bg-${variant}`;
    badge.textContent = message;
    badge.classList.remove('d-none');
  }

  function describeEntry(entry) {
    if (entry == null) return '';
    if (typeof entry === 'string') return entry;
    if (typeof entry === 'number' || typeof entry === 'boolean') return String(entry);
    if (Array.isArray(entry)) {
      return entry.map((item) => describeEntry(item)).join('; ');
    }
    const preferredKeys = ['title', 'topic', 'point', 'prompt', 'challenge', 'summary', 'question', 'recommendation', 'action', 'decision', 'note'];
    for (const key of preferredKeys) {
      if (entry[key]) return entry[key];
    }
    try {
      return JSON.stringify(entry);
    } catch (_) {
      return String(entry);
    }
  }

  function updateDiscussionTimestamp(ts) {
    if (!elements.discussionUpdatedAt) return;
    if (!ts) {
      elements.discussionUpdatedAt.textContent = '';
      return;
    }
    const date = ts instanceof Date ? ts : new Date(ts);
    if (Number.isNaN(date.getTime())) {
      elements.discussionUpdatedAt.textContent = '';
      return;
    }
    const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    elements.discussionUpdatedAt.textContent = `Updated ${timeString}`;
  }

  function renderSectionVisibility(sectionEl, hasContent) {
    if (!sectionEl) return;
    (hasContent ? show : hide)(sectionEl);
  }

  function renderDiscussionNarration(narration) {
    const target = elements.discussionNarration;
    if (!target) return;
    if (!narration) {
      target.innerHTML = '<span class="text-body-secondary fst-italic">AI discussion prep will appear here once generated.</span>';
      return;
    }
    const html = escapeHtml(narration).replace(/\n/g, '<br>');
    target.innerHTML = `<div class="small">${html}</div>`;
  }

  function renderDiscussionDecisions(decisions) {
    const container = elements.discussionDecisionList;
    const section = elements.discussionDecisionsBlock;
    if (!container) return;
    if (!Array.isArray(decisions) || decisions.length === 0) {
      container.innerHTML = 'No AI decisions captured yet.';
      renderSectionVisibility(section, false);
      return;
    }
    const items = decisions.map((decision) => {
      const topic = escapeHtml(decision.topic || 'Decision');
      const body = escapeHtml(decision.decision || '');
      const rationale = decision.rationale ? `<div class="text-body-secondary">${escapeHtml(decision.rationale)}</div>` : '';
      return `<li class="mb-2"><strong>${topic}</strong>${body ? `<div>${body}</div>` : ''}${rationale}</li>`;
    }).join('');
    container.innerHTML = `<ol class="mb-0 ps-3">${items}</ol>`;
    renderSectionVisibility(section, true);
  }

  function renderDiscussionNotes(notes) {
    const container = elements.discussionNoteList;
    const section = elements.discussionNotesBlock;
    if (!container) return;
    if (!Array.isArray(notes) || notes.length === 0) {
      container.innerHTML = 'No AI notes captured yet.';
      renderSectionVisibility(section, false);
      return;
    }
    const items = notes.map((note) => {
      const point = escapeHtml(note.point || describeEntry(note));
      const origin = note.origin ? `<span class="badge text-bg-light ms-1">${escapeHtml(note.origin)}</span>` : '';
      return `<li class="mb-1">${point}${origin}</li>`;
    }).join('');
    container.innerHTML = `<ul class="mb-0 ps-3">${items}</ul>`;
    renderSectionVisibility(section, true);
  }

function renderDevilAdvocate(items) {
  const container = elements.discussionDevilAdvocate;
  const section = elements.discussionDevilBlock;
  if (!container) return;

  if (!Array.isArray(items) || items.length === 0) {
    container.innerHTML = '<div class="text-muted fst-italic">No challenges queued yet.</div>';
    renderSectionVisibility(section, false);
    return;
  }

  const list = items.map((item) => {
    console.log(items)
    const title = escapeHtml(item.topic || item.title || `${item.cluster_title || ''}`);
    const counter = escapeHtml(item.counterargument || '');
    const question = escapeHtml(item.probing_question || '');

    return `
      <li class="mb-1">
        <strong>${title}</strong>
        <div class="mt-1">
          <div class="fw-semibold small text-danger">Counterargument</div>
          <div class="text-body-secondary mb-2">${counter}</div>
          <div class="fw-semibold small text-primary">Probing Question</div>
          <div class="text-body-secondary">${question}</div>
        </div>
      </li>`;
  }).join('');

  container.innerHTML = `<ul class="mb-0 ps-2 list-unstyled">${list}</ul>`;
  renderSectionVisibility(section, true);
}

  function renderMediatorPrompt(prompt) {
    const container = elements.discussionMediatorPrompt;
    const section = elements.discussionMediatorBlock;
    if (!container) return;
    if (!prompt) {
      container.innerHTML = 'Mediator suggestions will appear here.';
      renderSectionVisibility(section, false);
      return;
    }
    container.innerHTML = `<div class="small">${escapeHtml(prompt).replace(/\n/g, '<br>')}</div>`;
    renderSectionVisibility(section, true);
  }

  function renderScribeSummary(summary) {
    const container = elements.discussionScribeSummary;
    const section = elements.discussionScribeBlock;
    if (!container) return;
    if (!summary) {
      container.innerHTML = 'No scribe summary captured yet.';
      renderSectionVisibility(section, false);
      return;
    }
    container.innerHTML = `<div class="small">${escapeHtml(summary).replace(/\n/g, '<br>')}</div>`;
    renderSectionVisibility(section, true);
  }

  function renderActionItems(items) {
    const container = elements.discussionActionList;
    const section = elements.discussionActionBlock;
    if (!container) return;
    if (!Array.isArray(items) || items.length === 0) {
      container.innerHTML = 'No follow-up actions available.';
      renderSectionVisibility(section, false);
      return;
    }
    const list = items.map((item) => {
      const label = escapeHtml(item.title || item.action || describeEntry(item));
      const owner = item.owner ? `<span class="badge text-bg-light ms-1">${escapeHtml(item.owner)}</span>` : '';
      const due = item.due ? `<div class="text-body-secondary">Due: ${escapeHtml(item.due)}</div>` : '';
      return `<li class="mb-2">${label}${owner}${due}</li>`;
    }).join('');
    container.innerHTML = `<ul class="mb-0 ps-3">${list}</ul>`;
    renderSectionVisibility(section, true);
  }

  function refreshDiscussionUI() {
    renderDiscussionNarration(discussionState.narration);
    renderDiscussionDecisions(discussionState.decisions);
    renderDiscussionNotes(discussionState.notes);
    renderDevilAdvocate(discussionState.devilAdvocate);
    renderMediatorPrompt(discussionState.mediatorPrompt);
    renderScribeSummary(discussionState.scribeSummary);
    renderActionItems(discussionState.actionItems);
    updateDiscussionTimestamp(discussionState.updatedAt);
  }

  function applyDiscussionPayload(payload) {
    if (!payload || typeof payload !== 'object') return;
    discussionState.payload = payload;
    discussionState.narration = payload.narration || payload.task_description || '';
    if (Array.isArray(payload.decisions)) discussionState.decisions = payload.decisions;
    if (Array.isArray(payload.discussion_notes)) discussionState.notes = payload.discussion_notes;
    if (Array.isArray(payload.devil_advocate)) discussionState.devilAdvocate = payload.devil_advocate;
    if (Array.isArray(payload.action_items)) discussionState.actionItems = payload.action_items;
    if (payload.mediator_prompt) discussionState.mediatorPrompt = payload.mediator_prompt;
    if (payload.scribe_summary) discussionState.scribeSummary = payload.scribe_summary;
    discussionState.updatedAt = new Date();
    refreshDiscussionUI();
  }

  function applyDiscussionOutputs(outputs) {
    if (!outputs || typeof outputs !== 'object') return;
    if (Array.isArray(outputs.decisions) && outputs.decisions.length) {
      discussionState.decisions = outputs.decisions;
    }
    if (Array.isArray(outputs.discussion_notes) && outputs.discussion_notes.length) {
      discussionState.notes = outputs.discussion_notes;
    }
    if (Array.isArray(outputs.devil_advocate) && outputs.devil_advocate.length) {
      discussionState.devilAdvocate = outputs.devil_advocate;
    }
    if (outputs.mediator_prompt) {
      discussionState.mediatorPrompt = outputs.mediator_prompt;
    }
    if (outputs.scribe_summary) {
      discussionState.scribeSummary = outputs.scribe_summary;
    }
    if (Array.isArray(outputs.action_items) && outputs.action_items.length) {
      discussionState.actionItems = outputs.action_items;
    }
    discussionState.updatedAt = new Date();
    refreshDiscussionUI();
  }

  let discussionInitialLoadTriggered = false;
  let discussionActionInFlight = false;

  async function loadDiscussionPayload({ silent = false } = {}) {
    if (!isOrganizer && discussionInitialLoadTriggered && silent) {
      // Non-organizers only refresh via sockets after first load
      return;
    }
    try {
      const response = await fetch(`/api/workshops/${workshopId}/discussion`, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      const data = await response.json().catch(() => ({}));
      if (!response.ok || data.error) {
        if (!silent) console.warn('Failed to load discussion payload', data.error || response.statusText);
        return;
      }
      applyDiscussionPayload(data);
      discussionInitialLoadTriggered = true;
    } catch (err) {
      if (!silent) console.error('Failed to load discussion payload', err);
    }
  }

  async function performDiscussionAction(action, { button, requireConfirm = false } = {}) {
    if (!action || !DISCUSSION_ACTION_ENDPOINTS[action]) {
      return;
    }
    if (discussionActionInFlight) {
      return;
    }
    if (requireConfirm && !confirm('Are you sure?')) {
      return;
    }
    discussionActionInFlight = true;
    const endpoint = DISCUSSION_ACTION_ENDPOINTS[action];
    const label = DISCUSSION_ACTION_LABELS[action] || 'Working…';
    const successLabel = DISCUSSION_SUCCESS_LABELS[action] || 'Done';
    const url = `/api/workshops/${workshopId}/${endpoint}`;
    const body = {};
    const headers = {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest',
    };

    const restoreButton = () => {
      if (button) {
        button.disabled = false;
        if (button.dataset.origLabel) {
          button.innerHTML = button.dataset.origLabel;
          delete button.dataset.origLabel;
        }
      }
    };

    try {
      if (button) {
        button.disabled = true;
        button.dataset.origLabel = button.innerHTML;
        button.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Working…';
      }
      setDiscussionRunStatus(label, 'info');
      const response = await fetch(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(body),
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok || data.error) {
        throw new Error(data.error || `Request failed (${response.status})`);
      }
      if (data.task) {
        applyDiscussionPayload(data.task);
      }
      if (data.payload || data.outputs) {
        applyDiscussionOutputs(data.outputs || data.payload || {});
      }
      setDiscussionRunStatus(successLabel, 'success');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 4000);
      discussionInitialLoadTriggered = true;
    } catch (err) {
      console.error('Discussion action failed', err);
      alert(err && err.message ? err.message : 'Unable to complete the action.');
      setDiscussionRunStatus('Action failed', 'danger');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 4000);
    } finally {
      restoreButton();
      discussionActionInFlight = false;
    }
  }


  const renderListHtml = (items) => {
    if (!Array.isArray(items) || !items.length) {
      return '';
    }
    return `<ul class="mb-0 ps-3">${items.map((item) => `<li>${escapeHtml(item)}</li>`).join('')}</ul>`;
  };

  const renderSection = (label, bodyHtml) => {
    if (!bodyHtml) {
      return '';
    }
    return `<div class="mb-3"><div class="text-uppercase small text-body-secondary fw-semibold">${escapeHtml(label)}</div>${bodyHtml}</div>`;
  };

  const renderListSection = (label, items) => {
    const listHtml = renderListHtml(items);
    return listHtml ? renderSection(label, listHtml) : '';
  };



// Helper to read duration from any payload.
function _getDuration(payload) {
  return parseInt(
    payload.duration || payload.task_duration || payload.taskDuration || 0,
    10
  );
}


// --- Timer utilities ---
// Single implementation to avoid shadowing/duplication bugs
function clearCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
  // Do not reset display here; some callers want to show final state
}

  // Ensure the video conference starts automatically when enabled in the workshop
  function ensureConferenceAutoStartIfEnabled() {
    try {
      if (!(window.conferenceFlags && window.conferenceFlags.conferenceActive)) return;
      if (!window.VideoConference || typeof window.VideoConference.start !== 'function') return;
      // Pass flags then start if not already started
      try { if (typeof window.VideoConference.setFlags === 'function') window.VideoConference.setFlags(window.conferenceFlags); } catch (_) {}
      const st = (typeof window.VideoConference.getState === 'function') ? window.VideoConference.getState() : null;
      if (!st || !st.started) {
        window.VideoConference.start();
      }
    } catch (_) {}
  }

  // --- Utility Functions (postForm, clearCountdown, addStickyNote, updateParticipantsList, appendChatMessage) ---
  // (Keep these as they were in the previous correct version)
  // ...
  async function postForm(event, form) {
    event.preventDefault();
    const button = form.querySelector('button[type="submit"]');
    const originalHtml = button?.innerHTML;
    if (button) {
      button.disabled = true;
      button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';
    }

    try {
      const res = await fetch(form.action, {
        method: 'POST',
        body: new FormData(form),
        headers: { 'X-Requested-With': 'XMLHttpRequest' }
      });

      const contentType = res.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        const data = await res.json();
        if (res.ok && data.success) {
          console.log("Form submitted successfully (JSON):", data.message || "Action completed.");
          if (data.redirect_url) {
            window.location.href = data.redirect_url;
          }
          // For pause/resume, rely on socket events + reload
        } else {
          throw new Error(data.message || `Request failed: ${res.status}`);
        }
      } else if (res.ok && res.redirected) {
        window.location.href = res.url;
      } else if (!res.ok) {
        throw new Error(`Request failed: ${res.status}`);
      } else {
        console.log("Form submitted successfully (non-JSON).");
      }
    } catch (err) {
      console.error("Form submission error:", err);
      alert('Error: ' + err.message);
    } finally {
      if (button) {
        button.disabled = false;
        button.innerHTML = originalHtml;
      }
    }
  }

  // Reset and blank out the timer completely
  function resetTimerVisuals() {
    clearCountdown();
    elements.progressBar.style.width = '0%';
    elements.timerText.textContent = '00:00';
    if (elements.sessionFlowTimer) {
      elements.sessionFlowTimer.textContent = '00:00';
    }
    totalDurationForCurrentTask = 0;
  }

  function rebuildWhiteboardPlaceholder(showImmediately = false) {
    if (!elements.stickyBoard) return;
    elements.stickyBoard.innerHTML = `<p id="idea-placeholder" class="text-muted small fst-italic w-100 text-center mt-3" style="display:none;">Ideas will appear here...</p>`;
    elements.ideaPlaceholder = document.getElementById('idea-placeholder');
    if (elements.ideaPlaceholder) {
      elements.ideaPlaceholder.style.display = showImmediately ? 'block' : 'none';
    }
  }

  function hydrateWhiteboardFromIdeas(ideas, options = {}) {
    if (!elements.stickyBoard || !Array.isArray(ideas)) return;
    const prefix = options.tempPrefix || 'idea';
    const defaultSource = options.defaultSource || 'human';
    const includeDefault = options.includeByDefault;

    ideas.forEach((idea, idx) => {
      if (!idea) return;
      const rawContent = idea.content ?? idea.text;
      if (typeof rawContent === 'undefined' || rawContent === null) return;
      const trimmed = String(rawContent).trim();
      if (!trimmed) return;

      const includeInOutputs = (typeof idea.include_in_outputs === 'boolean')
        ? idea.include_in_outputs
        : (typeof includeDefault === 'boolean' ? includeDefault : true);

      let metadataPayload;
      try {
        const baseMeta = (idea.metadata && typeof idea.metadata === 'object') ? { ...idea.metadata } : {};
        if (!baseMeta.tags && Array.isArray(idea.tags) && idea.tags.length) {
          baseMeta.tags = idea.tags;
        }
        if (!baseMeta.inspiration && idea.inspiration) {
          baseMeta.inspiration = idea.inspiration;
        }
        if (Object.keys(baseMeta).length) {
          metadataPayload = baseMeta;
        }
      } catch (_) {
        metadataPayload = undefined;
      }

      addStickyNote({
        idea_id: idea.idea_id || idea.id || idea.ideaId || `${prefix}-${idx}`,
        user: idea.user || idea.participant_name || idea.author || idea.created_by || null,
        content: trimmed,
        source: idea.source || defaultSource,
        rationale: idea.rationale,
        metadata: metadataPayload,
        include_in_outputs: includeInOutputs,
      });
    });
  }

  function applyAiIncludeVisual(note, include) {
    if (!note) return;
    if (include) {
      note.classList.remove('ai-sticky-excluded');
      const footer = note.querySelector('.ai-idea-excluded-note');
      if (footer) {
        footer.remove();
      }
    } else {
      note.classList.add('ai-sticky-excluded');
      let footer = note.querySelector('.ai-idea-excluded-note');
      if (!footer) {
        footer = document.createElement('div');
        footer.className = 'ai-idea-excluded-note small text-body-secondary mt-2';
        footer.innerHTML = '<i class="bi bi-slash-circle me-1"></i>Excluded from downstream reports';
        note.appendChild(footer);
      } else {
        footer.classList.remove('d-none');
      }
    }
  }

  function addStickyNote({ user, content, idea_id, source, rationale, metadata, include_in_outputs = true }) {
    if (!elements.stickyBoard) return;
    elements.ideaPlaceholder.style.display = 'none';
    const note = document.createElement("div");
    // Basic sanitization (replace with a more robust library if needed)
    const safeUser = (user || 'Unknown').replace(/</g, "&lt;").replace(/>/g, "&gt;");
    const safeContent = (content || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");
    const ideaSource = (source || 'human').toLowerCase();
    const includeFlag = include_in_outputs !== false;

    note.className = "sticky-note border p-2 bg-warning shadow-sm";
    //note.style.minWidth = '100px';
    note.style.width = '200px';
    note.style.minHeight = '60px';
    note.style.wordWrap = 'break-word';
    note.id = `idea-${idea_id}`; // Ensure idea_id is passed
    note.dataset.source = ideaSource;
    if (rationale) note.dataset.rationale = rationale;
    if (metadata) {
      try { note.dataset.metadata = JSON.stringify(metadata); }
      catch (_) {}
    }
    if (typeof include_in_outputs !== 'undefined') {
      note.dataset.includeInOutputs = includeFlag ? 'true' : 'false';
    }

    const displayName = ideaSource === 'ai' ? 'AI Facilitator' : safeUser;
    const badge = ideaSource === 'ai' ? '<span class="badge bg-info-subtle text-info-emphasis ms-1">AI Seed</span>' : '';
    note.innerHTML = `<strong class="d-block text-truncate small" title="${safeUser}">${displayName}${badge}</strong><p class="mb-0 small">${safeContent}</p>`;
    if (ideaSource === 'ai') {
      note.classList.add('ai-sticky-note');
      applyAiIncludeVisual(note, includeFlag);
    }
    elements.stickyBoard.appendChild(note);
  }

  function setAiIdeaIncludeState(include, options = {}) {
    const preserveIdeaFlags = !!options.preserveIdeaFlags;
    const skipSwitch = !!options.skipSwitch;
    aiIdeaIncludeState = !!include;

    if (elements.aiIdeaIncludeSwitch && !skipSwitch) {
      elements.aiIdeaIncludeSwitch.checked = aiIdeaIncludeState;
    }
    if (elements.aiIdeaIncludeHint) {
      elements.aiIdeaIncludeHint.textContent = aiIdeaIncludeState
        ? 'AI facilitator ideas feed into clustering, reports, and exports.'
        : 'AI facilitator ideas stay on the board but remain out of downstream reports.';
    }
    if (elements.aiIdeaIncludeBanner) {
      if (aiIdeaIncludeState) {
        hide(elements.aiIdeaIncludeBanner);
      } else {
        show(elements.aiIdeaIncludeBanner);
      }
    }

    document.querySelectorAll('.sticky-note[data-source="ai"]').forEach(note => {
      if (!preserveIdeaFlags) {
        note.dataset.includeInOutputs = aiIdeaIncludeState ? 'true' : 'false';
      }
      const includeFlag = note.dataset.includeInOutputs !== 'false';
      applyAiIncludeVisual(note, includeFlag);
    });
  }

 function updateParticipantsList(participants) {
    if (!elements.participantsList) return;
    // Reset list content and scroll position for predictable top-anchored rendering
    elements.participantsList.innerHTML = '';
    elements.participantsList.scrollTop = 0;
    const count = Array.isArray(participants) ? participants.length : 0;
    if (elements.participantsCount) {
      elements.participantsCount.textContent = count + (count === 1 ? ' participant' : ' participants');
    }
    if (!participants || !participants.length) {
      const empty = document.createElement('div');
      empty.className = 'p-3 text-center text-body-secondary';
      empty.textContent = 'No participants yet.';
      elements.participantsList.appendChild(empty);
      return;
    }
    const resolveProfilePic = (p) => {
      try {
        const raw = (p && (p.profile_pic_url || p.profile_image)) || '';
        if (!raw) return "{{ profile_url(None) }}";
        if (raw.startsWith('http://') || raw.startsWith('https://')) return raw;
        if (raw.startsWith('/media/') || raw.startsWith('/static/')) return raw;
        // If backend sent a relative path like "images/foo.png" or "uploads/foo.jpg"
        // treat it as static by default
        return '/static/' + raw.replace(/^\/+/, '');
      } catch { return "{{ profile_url(None) }}"; }
    };

    // High‑quality UX: keep organizer(s) first, then alphabetical by name/email
    const sortRank = (participant) => {
      if (participant?.is_organizer) return 0;
      if (participant?.is_facilitator) return 1;
      return 2;
    };
    const normalizedName = (participant) => {
      if (!participant) return '';
      const display = (participant.display_name || '').toString().trim();
      if (display) return display.toLowerCase();
      const combined = [participant.first_name, participant.last_name]
        .filter(Boolean)
        .join(' ')
        .trim();
      if (combined) return combined.toLowerCase();
      const email = (participant.email || '').toString();
      if (email.includes('@')) return email.split('@')[0].toLowerCase();
      return email.toLowerCase();
    };
    const sorted = [...participants].sort((a, b) => {
      const rankDelta = sortRank(a) - sortRank(b);
      if (rankDelta !== 0) return rankDelta;
      return normalizedName(a).localeCompare(normalizedName(b));
    });

    const frag = document.createDocumentFragment();
    sorted.forEach(p => {
      const organizerFlag = !!(p && (p.is_organizer || String(p.role || '').toLowerCase() === 'organizer'));
      const facilitatorFlag = !!(p && (p.is_facilitator || FACILITATOR_ROLE_KEYS.has(String(p.role || '').toLowerCase())));
      // Treat as public by default; only private when the flag is explicitly false/0/"false"
      const vis = (p.is_public_profile ?? p.public_profile);
      const isPublicProfile = (vis === undefined)
        ? true
        : (vis === true || vis === 1 || vis === '1' || vis === 'true');
      const linkable = isPublicProfile; // only link when profile is public
      const li = document.createElement(linkable ? 'a' : 'div');
      li.className = 'list-group-item d-flex align-items-start gap-2' + (linkable ? ' list-group-item-action' : '');
      if (linkable) {
        const tpl = elements.participantsList?.dataset?.profileUrlTemplate || '/account/profile/0';
        const profileHref = tpl.replace(/0$/, String(p.user_id || p.id || 0));
        li.href = profileHref;
        li.setAttribute('aria-label', 'View profile');
      } else {
        li.setAttribute('title', 'Private profile');
        li.style.cursor = 'not-allowed';
      }
      const profilePic = resolveProfilePic(p);
      const roleKey = (() => {
        const raw = String(p.role || '').toLowerCase();
        if (raw) return raw;
        if (organizerFlag) return 'organizer';
        if (facilitatorFlag) return 'facilitator';
        return 'participant';
      })();
      const roleBadge = ROLE_BADGE_META[roleKey];
      const badges = [];
      if (roleBadge) {
        badges.push(`<span class="${roleBadge.className}" data-role="${roleKey}">${roleBadge.label}</span>`);
      }
      if (facilitatorFlag && !(roleBadge && roleBadge.impliesFacilitator)) {
        const facilitatorMeta = ROLE_BADGE_META.facilitator;
        badges.push(`<span class="${facilitatorMeta.className}" data-role="facilitator">${facilitatorMeta.label}</span>`);
      }
      badges.push('<span class="badge text-bg-success">Online</span>');
      if (!isPublicProfile) {
        badges.push('<span class="badge text-bg-secondary" title="Private profile"><i class="bi bi-shield-lock"></i> Private</span>');
      }

      const displayName = (() => {
        const preferred = (p.display_name || '').toString().trim();
        if (preferred) return preferred;
        const fromNames = [p.first_name, p.last_name].filter(Boolean).join(' ').trim();
        if (fromNames) return fromNames;
        if (p.email) {
          const [localPart] = p.email.split('@');
          if (localPart) return localPart;
        }
        return 'User';
      })();
      const email = p.email || '';
      li.innerHTML = `
        <span class="avatar-circle avatar-32 d-inline-block overflow-hidden border"><img src="${profilePic}" alt="avatar" class="avatar-img" onerror="this.onerror=null; this.src='{{ profile_url(None) }}';"></span>
        <div class="flex-grow-1">
          <div class="fw-semibold text-truncate">${displayName}</div>
          ${email ? `<div class="text-body-secondary text-truncate">${email}</div>` : ''}
          <div class="mt-1 d-flex flex-wrap gap-1">${badges.join('')}</div>
        </div>
      `;
      frag.appendChild(li);
    });
    elements.participantsList.appendChild(frag);
  }

  function appendChatMessage(userName, message, timestamp, isHistory = false, messageType = 'user') {
      if (!elements.chatMessages) return;
      const el = document.createElement('div');
    el.classList.add('mb-1', 'small');

      const safeUserName = (userName || 'System').replace(/</g, "&lt;").replace(/>/g, "&gt;");
      const safeMessage = (message || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");

      let timeString = '';
      if (timestamp) {
          try {
              timeString = `<span class="text-muted ms-1 fs-07">${new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>`;
          } catch (e) { console.warn("Could not parse timestamp:", timestamp); }
      }
    let pillClass = '';
    let pillText = '';
    let nameLabel = safeUserName;
    const type = (messageType || '').toString();
    if (type === 'facilitator') {
      pillClass = 'badge text-bg-warning-subtle text-warning-emphasis me-1';
      pillText = 'Facilitator';
    } else if (type === 'system') {
      pillClass = 'badge text-bg-secondary me-1';
      pillText = 'System';
    }
    const pill = pillClass ? `<span class="${pillClass}">${pillText}</span>` : '';
    el.innerHTML = `${pill}<strong>${nameLabel}</strong>: ${safeMessage}${timeString}`;
      elements.chatMessages.appendChild(el);
      // Scroll down only for new messages, not history
      if (!isHistory) {
          elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      }
  }


  // --- New: task‑completion handler ---
  function handleTaskCompletion() {
      // Only act when the introduction (warm‑up) task finishes
      if (currentTaskType === 'warm-up' || currentTaskType === 'introduction') {
          /* Hide “Begin Workshop / Workshop Started” button */
          if (elements.beginIntroForm) {
              elements.beginIntroForm.style.display = 'none';
          }
          /* Show & enable “Next Task” button */
          if (elements.nextTaskBtn) {
              elements.nextTaskBtn.style.display = 'inline-block';
              elements.nextTaskBtn.disabled = false;
              
          }
          /* Tell the server the task has ended (organizer only) */
          if (isOrganizer && currentTaskId) {
              socket.emit('task_completed', {
                  workshop_id: workshopId,
                  task_id: currentTaskId,
                  room: roomName
              });
          }
      }
  }








  // --- Core UI Update Functions ---

  function startOrSyncCountdown(remainingSeconds, totalDuration) {
    console.log(`startOrSyncCountdown called with remaining: ${remainingSeconds}, total: ${totalDuration}`);
    clearCountdown(); // Clear any existing timer first

    // Normalize duration & remaining inputs so downstream math never sees NaN
    const parsedTotal = Number(totalDuration);
    totalDurationForCurrentTask = Number.isFinite(parsedTotal) && parsedTotal > 0
      ? Math.floor(parsedTotal)
      : 0;

    if (totalDurationForCurrentTask <= 0) {
      console.warn('startOrSyncCountdown: Invalid totalDuration', totalDuration);
      if (elements.timerText) {
        elements.timerText.textContent = '00:00';
      }
      if (elements.sessionFlowTimer) {
        elements.sessionFlowTimer.textContent = '00:00';
      }
      if (elements.progressBar) {
        elements.progressBar.style.width = '100%';
      }
      return;
    }

    const parsedRemaining = Number(remainingSeconds);
    let remaining = Number.isFinite(parsedRemaining) ? Math.floor(parsedRemaining) : totalDurationForCurrentTask;
    if (remaining < 0) remaining = 0;

    const render = () => {
      const safeRemaining = Math.max(0, remaining);
      const mm = String(Math.floor(safeRemaining / 60)).padStart(2, '0');
      const ss = String(safeRemaining % 60).padStart(2, '0');
      if (elements.timerText) {
        elements.timerText.textContent = `${mm}:${ss}`;
      }
      if (elements.sessionFlowTimer) {
        elements.sessionFlowTimer.textContent = `${mm}:${ss}`;
      }
      const elapsed = totalDurationForCurrentTask - safeRemaining;
      const pct = totalDurationForCurrentTask > 0
        ? Math.min(100, Math.max(0, (elapsed / totalDurationForCurrentTask) * 100))
        : 0;
      if (elements.progressBar) {
        elements.progressBar.style.width = `${pct}%`;
      }
    };

    // Initial render
    render();

    if (remaining <= 0) {
      console.log(`Timer already finished for task ${currentTaskId}`);
      handleTimerEnd();
      return;
    }

    if (workshopStatus !== 'paused') {
      console.log('Starting countdown interval...');
      countdownInterval = setInterval(() => {
        remaining -= 1;
        render();
        if (remaining <= 0) {
          handleTimerEnd();
        }
      }, 1000);
    } else {
      console.log('Countdown not started because workshop is paused.');
    }
  }

  function handleTimerEnd() {
      console.log(`Timer finished for task ${currentTaskId}`);
  // Stop ticking but keep final UI values
      if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
      }
      elements.timerText.textContent = '00:00';
      if (elements.sessionFlowTimer) {
        elements.sessionFlowTimer.textContent = '00:00';
      }
      elements.progressBar.style.width = '100%';

    // Disable relevant inputs based on task type
      // Auto-advance after a short delay (organizer present and enabled),
      // but NEVER auto-advance while the workshop is paused
      if (workshopStatus !== 'paused' && autoAdvanceEnabled && autoAdvanceDelaySeconds > 0 && isOrganizer) {
        if (autoAdvanceTimeout) clearTimeout(autoAdvanceTimeout);
        autoAdvanceTimeout = setTimeout(() => {
          if (workshopStatus !== 'paused' && !elements.nextTaskBtn?.disabled) {
            elements.nextTaskBtn.click();
          }
        }, autoAdvanceDelaySeconds * 1000);
      }
  if (currentTaskType === 'clustering_voting') {
        // Disable all vote buttons
        elements.clusterVotingArea.querySelectorAll('.vote-btn').forEach(btn => btn.disabled = true);
  } else if (currentTaskType === 'vote_generic') {
    const scope = elements.genericVotingArea || document;
    scope.querySelectorAll('#generic-vote-container .generic-vote-btn').forEach(btn => btn.disabled = true);
    } else {
        // Disable idea form
        elements.ideaFormContainer.style.display = 'none';
        elements.ideaSubmitBtn.disabled = true;
        elements.ideaInput.disabled = true;
    }

      // Enable and show "Next Task" button for organizer, hide "Begin Workshop"
      if (isOrganizer && elements.nextTaskBtn) {
          elements.nextTaskBtn.disabled = false;
          elements.nextTaskBtn.innerHTML = 'Next Task';
          elements.nextTaskBtn.style.display = 'inline-block';
          if (elements.beginIntroForm) {
              elements.beginIntroForm.style.display = 'none';
          }
      }

      // If no ideas were submitted during warm-up/brainstorming, show a note
      if ((currentTaskType === 'warm-up' || currentTaskType === 'brainstorming') && elements.stickyBoard) {
        const anyNotes = elements.stickyBoard.querySelector('.sticky-note');
        if (!anyNotes) {
          elements.stickyBoard.style.display = 'block';
          elements.stickyBoard.innerHTML = '<p class="text-muted small fst-italic w-100 text-center my-3">No responses were submitted.</p>';
        }
      }
  }


  function displayTask(data) {
    console.log("Displaying task:", data);
    // Keep last task payload globally for TTS buttons and other consumers
    try { window._lastTaskPayload = data; } catch(_) {}
    
  currentTaskId = data.task_id;
    currentTaskType = data.task_type; // Store the task type
    // Task index provided by server; if missing, try to derive from plan
    if (typeof data.task_index === 'number') {
      currentTaskIndex = data.task_index;
    } else {
      // Fallback derive from plan
      if (planCache && Array.isArray(planCache.current_plan)) {
        const idx = planCache.current_plan.findIndex((n, i) => i >= 0 && (n.task_type === currentTaskType || n.task_type === (currentTaskType === 'warm-up' ? 'warm-up' : currentTaskType)));
        currentTaskIndex = idx >= 0 ? idx : null;
      } else {
        currentTaskIndex = null;
      }
    }
  // Update phase badge and session flow highlight
  updatePhaseUI(currentTaskType, data.phase_context);
  renderSessionFlow();
  // Server may send duration in 'task_duration' or 'duration'
  const rawDur = (typeof data.task_duration !== 'undefined') ? data.task_duration : data.duration;
  totalDurationForCurrentTask = parseInt(rawDur, 10) || 0;
    console.log(`Set totalDurationForCurrentTask to: ${totalDurationForCurrentTask}`);

    // --- Reset UI ---
  hide(elements.taskPlaceholder);
  show(elements.taskContent);
  // Update phase badge and session flow highlight
  hide(elements.stickyBoard); // Hide whiteboard by default; only show for idea-entry tasks
  hide(elements.clusterVotingArea);
  hide(elements.genericVotingArea);
  hide(elements.reportArea);
  if (elements.aiIdeaControls) hide(elements.aiIdeaControls);
  if (elements.aiIdeaIncludeBanner) hide(elements.aiIdeaIncludeBanner);
  // Hide forum section by default; will be shown only during Discussion
  try { hide(document.getElementById('discussion-forum-section')); } catch(_) {}
  // Facilitator advanced controls are always visible; stop audio and re-init per phase
  try { if (window.FacilitatorTTS) { window.FacilitatorTTS.cancelSpeech(); } } catch(_) {}
  hide(elements.ideaFormContainer);
  hide(elements.userDotsDisplay); // Hide dots display by default
    elements.clusterVotingArea.innerHTML = ''; // Clear previous clusters
    if (elements.genericVotingArea) elements.genericVotingArea.innerHTML = '';
    elements.reportArea.innerHTML = ''; // Clear previous report
  try {
    if (window.ResultsViewer && typeof window.ResultsViewer.teardown === 'function') {
      window.ResultsViewer.teardown();
    } else {
      document.querySelectorAll('.presentation-viewer-box').forEach(node => { try { node.remove(); } catch (_) { /* ignore */ } });
      document.querySelectorAll('.pdf-link-block[data-rv-owned]').forEach(node => { try { node.remove(); } catch (_) { /* ignore */ } });
    }
  } catch (_) { /* ignore */ }
  // Reset whiteboard placeholder, but keep it hidden unless an idea-entry task is active
  rebuildWhiteboardPlaceholder(false);

    // Remove any existing Speech large preview when switching tasks; will be re-inserted during speech phase
    try { document.querySelectorAll('.speech-spotlight-box').forEach(n => n.remove()); } catch(_) {}



    // --- Update AI Facilitator Area ---
    const facilitatorPanel = data.facilitator_panel || {};
    const headingText = (data.task_type === 'framing' && facilitatorPanel.opening_keynote)
      ? facilitatorPanel.opening_keynote
      : (facilitatorPanel.task_title || data.title || 'Introduction and warm-up');
    elements.taskTitle.textContent = headingText;
    elements.taskBody.innerHTML = ''; // Clear previous body

    // --- Populate Task Body based on Type ---
    let instructions = data.instructions || "Please follow the instructions.";
    let description = data.description || data.task_description || "";
    const isWarmupTask = (currentTaskType === 'warm-up' || currentTaskType === 'warm_up');

    if (!isWarmupTask) {
        try {
            window.warmupOptions = [];
            window.selectedWarmupIndex = 0;
        } catch (_) {
            /* no-op */
        }
    }

    if (isWarmupTask) {  // Support both formats
        // Extract selected warm-up option
        const selectedOption = data.selected_option || (data.options && data.options[data.selected_index || 0]);
        const mode = selectedOption?.mode || 'solo';
        const prompt = selectedOption?.prompt || data.task_description;
        
        elements.taskBody.innerHTML = `
            <div class="mb-3">
                <span class="badge bg-info text-dark mb-2">
                    <i class="bi bi-${mode === 'pairs' ? 'people' : mode === 'groups' ? 'people-fill' : 'person'}"></i> 
                    ${mode.charAt(0).toUpperCase() + mode.slice(1)} Activity
                </span>
            </div>
            <p class="mb-2">${data.facilitator_intro || ''}</p>
            <div class="alert alert-light border-start border-4 border-primary">
                <h5 class="alert-heading">${selectedOption?.title || 'Warm-Up Activity'}</h5>
                <p class="mb-0 fs-5">${prompt}</p>
            </div>
            <p class="mb-2 text-muted small">${data.participation_norms || ''}</p>
            <hr>
            <p class="mb-2 fw-bold">Instructions</p>
            <p class="mb-2">${data.instructions || data.warm_up_instructions || ''}</p>
            ${isOrganizer && data.options ? `
                <div class="mt-3">
                    <button class="btn btn-sm btn-outline-secondary" onclick="showWarmupOptions()">
                        <i class="bi bi-list-ul"></i> View All Options
                    </button>
                </div>
            ` : ''}`;
        
        elements.leftColumnTitle.textContent = "Responses";
        show(elements.stickyBoard);
        show(elements.ideaFormContainer);
        
        // Store options globally for organizer to switch if needed
        if (data.options) {
            window.warmupOptions = data.options;
            window.selectedWarmupIndex = Number.isInteger(data.selected_index) ? data.selected_index : 0;
        }
        
        try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
    } else if (currentTaskType === 'brainstorming') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions}</p>`;
        elements.leftColumnTitle.textContent = "Whiteboard";
        show(elements.stickyBoard);
        show(elements.ideaFormContainer);
        if (elements.aiIdeaControls) show(elements.aiIdeaControls);
        const includeToggle = (typeof data.ai_ideas_include_in_outputs !== 'undefined')
          ? !!data.ai_ideas_include_in_outputs
          : true;
        setAiIdeaIncludeState(includeToggle, { preserveIdeaFlags: false });

        const aiSeeds = Array.isArray(data.ai_ideas) ? data.ai_ideas : [];
        if (aiSeeds.length) {
          hydrateWhiteboardFromIdeas(aiSeeds, {
            defaultSource: 'ai',
            tempPrefix: `ai-seed-${currentTaskId || 'task'}`,
            includeByDefault: includeToggle,
          });
          setAiIdeaIncludeState(includeToggle, { preserveIdeaFlags: true, skipSwitch: true });
        } else if (elements.ideaPlaceholder) {
          elements.ideaPlaceholder.style.display = 'block';
        }
        try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
    } else if (currentTaskType === 'clustering_voting') {
    // Prefer server-provided dots_per_user to phrase instructions on first render
    const configuredDots = (typeof data.dots_per_user === 'number') ? data.dots_per_user : null;
    const introText = description || 'Ideas have been clustered. Please vote for the clusters you find most promising.';
    const instrText = instructions || (
      configuredDots != null
      ? `Each participant has ${configuredDots} dot${configuredDots===1?'':'s'}. Use them to vote for the clusters you find most promising.`
      : `Use your dots to vote. You have ${userDots} dots remaining.`
    );
    elements.taskBody.innerHTML = `
      <p class="fs-5 mb-2">${introText}</p>
      <p class="mb-1"><strong>Instructions:</strong></p>
      <p>${instrText}</p>`;
        elements.leftColumnTitle.textContent = "Clusters & Voting";
  show(elements.clusterVotingArea);
  show(elements.userDotsDisplay);
        renderClusters(data.clusters || []); // Render the clusters
        // Sync initial dots for the current user
        if (data.participants_dots && data.participants_dots[userId] !== undefined) {
            updateUserDots(data.participants_dots[userId]);
        }
  } else if (currentTaskType === 'results_feasibility') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description || 'Voting has concluded. Here is the feasibility analysis:'}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions || 'Review the analysis below and prepare for discussion.'}</p>`;
    elements.leftColumnTitle.textContent = "Feasibility Report";
    const pdfUrl = data.feasibility_pdf_url;
    const canUseResultsViewer = !!(pdfUrl && window.ResultsViewer && typeof window.ResultsViewer.mountViewer === 'function');
    if (canUseResultsViewer) {
      elements.reportArea.innerHTML = '';
      show(elements.reportArea);
      if (typeof window.ResultsViewer.injectPdfLinks === 'function') {
        window.ResultsViewer.injectPdfLinks(elements.reportArea, {
          pdfUrl,
          kind: 'feasibility',
          openText: 'Open report PDF'
        });
      }
      window.ResultsViewer.mountViewer({
        containerEl: elements.reportArea,
        pdfUrl,
        kind: 'feasibility',
        taskId: data.task_id,
        canControl: !!isOrganizer,
        socket,
        roomName,
        workshopId,
        userId,
        controlEvent: 'feasibility_control',
        syncEvent: 'feasibility_sync',
        roleNoteText: 'Feasibility Report'
      });
    } else {
          show(elements.reportArea);
          // Render the feasibility report content if provided (Markdown supported when marked.js is available)
          try {
            const txt = (data.feasibility_report || '').toString();
            if (txt && txt.trim().length > 0) {
              if (window.marked && typeof window.marked.parse === 'function') {
                elements.reportArea.innerHTML = window.marked.parse(txt);
              } else {
                // Graceful fallback without marked: show as preformatted text
                const safe = txt.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
                elements.reportArea.innerHTML = `<div class="small">${safe}</div>`;
              }
            } else {
              elements.reportArea.innerHTML = '<p class="text-muted">No feasibility report available.</p>';
            }
          } catch (_) {
            elements.reportArea.innerHTML = '<p class="text-muted">No feasibility report available.</p>';
          }
        }
        try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
    } else if (currentTaskType === 'discussion') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description || 'Let\'s discuss the findings.'}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions || 'Use the chat to share your thoughts.'}</p>`;
        // No specific left column needed, chat is on the right
        elements.leftColumnTitle.textContent = "Discussion";
      // REPLACE chat scope handling
  try { setChatScopeDefaultIfUnset('discussion_chat'); } catch(_) {}
      // Mount the forum UI
      try {
        const forumSection = document.getElementById('discussion-forum-section');
        if (forumSection) { show(forumSection); }
        if (!window.__forumMounted && window.DiscussionForum && typeof window.DiscussionForum.mount === 'function') {
          window.DiscussionForum.mount(workshopId);
          window.__forumMounted = true;
        }
      } catch(_) {}
      loadDiscussionPayload({ silent: discussionInitialLoadTriggered }).catch((err) => console.warn('Discussion payload load failed', err));
  } else if (currentTaskType === 'meeting') {
      // Minimal meeting phase rendering
      elements.taskBody.innerHTML = `
        <p class="fs-5 mb-2">${description || 'Team sync and logistics.'}</p>
        <p class="mb-1"><strong>Instructions:</strong></p>
        <p>${instructions || 'Use the video conference and chat to coordinate. The timer helps keep us on track.'}</p>`;
      elements.leftColumnTitle.textContent = 'Meeting';
      try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
  } else if (currentTaskType === 'presentation') {
      // Presentation phase rendering; adapt UI based on mode (slideshow | shortlisting | action_plan)
      const presenter = (data.presenter_user_id != null) ? `<li><strong>Presenter:</strong> User #${data.presenter_user_id}</li>` : '';
      const mode = (data.mode || 'shortlisting');
      const docInfo = (() => {
        const d = data.document || null;
        if (!d && data.document_id != null) return `<li><strong>Document ID:</strong> ${data.document_id}</li>`;
        if (!d) return '';
        const size = (d.file_size && d.file_size > 0)
          ? (d.file_size > 1048576 ? `${(d.file_size/1048576).toFixed(1)} MB` : `${Math.ceil(d.file_size/1024)} KB`)
          : '';
        const title = (d.title || d.file_name || `Document #${d.id}`);
        return `<li><strong>Document:</strong> ${title}${size? ` <span class=\"text-body-secondary\">(${size})</span>`:''}</li>`;
      })();
      const slide = (data.initial_slide_index != null) ? `<li><strong>Start at slide:</strong> ${data.initial_slide_index}</li>` : '';
      // Tailor description/instructions for mode
      const baseDesc = description || (mode === 'slideshow' ? 'Presenter will walk through the selected document or slides.' : (mode === 'action_plan' ? 'Review the proposed action plan.' : 'Review the prioritized shortlist.'));
      const baseInstr = instructions || (mode === 'slideshow' ? 'Follow along in the viewer. Use chat for questions.' : 'Discuss and confirm together.');
      elements.taskBody.innerHTML = `
        <p class="fs-5 mb-2">${baseDesc}</p>
        <p class="mb-1"><strong>Instructions:</strong></p>
        <p>${baseInstr}</p>
        ${(presenter || (mode==='slideshow' ? (docInfo+slide) : '')) ? `<ul class="small">${presenter}${mode==='slideshow' ? (docInfo+slide) : ''}</ul>` : ''}
        ${mode==='shortlisting' && Array.isArray(data.shortlist) ? `<div class="small mt-2"><strong>Shortlist (${data.shortlist.length}):</strong><ol class="mt-1">${(data.shortlist||[]).slice(0,10).map(it=>`<li>${(it.label||'').toString().replace(/</g,'&lt;').replace(/>/g,'&gt;')}</li>`).join('')}</ol></div>` : ''}
        ${mode==='shortlisting' && data.shortlist_pdf_url ? `<div class="mt-2 d-flex align-items-center gap-2 pdf-link-block" data-kind="shortlist">
          <a class="btn btn-sm btn-outline-primary" href="${data.shortlist_pdf_url}" target="_blank" rel="noopener">Open shortlist PDF</a>
          <a class="btn btn-sm btn-primary" href="${data.shortlist_pdf_url}" download>Download</a>
          <span class="badge text-bg-light ms-1 pdf-pages-badge d-none" data-kind="shortlist" title="Total pages">—</span>
        </div>` : ''}
        ${mode==='action_plan' && data.action_plan_pdf_url ? `<div class="mt-2 d-flex align-items-center gap-2 pdf-link-block" data-kind="action_plan">
          <a class="btn btn-sm btn-outline-primary" href="${data.action_plan_pdf_url}" target="_blank" rel="noopener">Open action plan PDF</a>
          <a class="btn btn-sm btn-primary" href="${data.action_plan_pdf_url}" download>Download</a>
          <span class="badge text-bg-light ms-1 pdf-pages-badge d-none" data-kind="action_plan" title="Total pages">—</span>
        </div>` : ''}
      `;
      elements.leftColumnTitle.textContent = (mode === 'slideshow') ? 'Presentation' : (mode === 'action_plan' ? 'Action Plan' : 'Shortlist');
      try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
      
      // Mount a presentation viewer box for slideshow, and also when a generated PDF exists (shortlisting/action_plan)
      try {
        // Remove any pre-existing box from previous renders
        document.querySelectorAll('.presentation-viewer-box').forEach(n => n.remove());
        // Decide if we should render a viewer
        const hasShortlistPdf = (mode === 'shortlisting') && !!data.shortlist_pdf_url;
        const hasActionPlanPdf = (mode === 'action_plan') && !!data.action_plan_pdf_url;
        const shouldRenderViewer = (mode === 'slideshow') || hasShortlistPdf || hasActionPlanPdf;
        if (!shouldRenderViewer) {
          // No viewer to render; keep summary/buttons only
          return;
        }
        const box = document.createElement('div');
        box.className = 'presentation-viewer-box mt-2';
        box.innerHTML = `
          <div class="presentation-controls d-flex align-items-center gap-2 mb-2">
            <div class="btn-group btn-group-sm" role="group" aria-label="Presentation controls">
              <button class="btn btn-outline-secondary pres-prev" title="Previous slide"><i class="bi bi-caret-left-fill"></i></button>
              <button class="btn btn-outline-secondary pres-next" title="Next slide"><i class="bi bi-caret-right-fill"></i></button>
            </div>
            <div class="btn-group btn-group-sm ms-1" role="group" aria-label="Zoom">
              <button class="btn btn-outline-secondary pres-zoom-out" title="Zoom out"><i class="bi bi-zoom-out"></i></button>
              <button class="btn btn-outline-secondary pres-zoom-in" title="Zoom in"><i class="bi bi-zoom-in"></i></button>
              <button class="btn btn-outline-secondary pres-fit" data-fit="width" title="Fit width"><i class="bi bi-arrows-fullscreen"></i></button>
              <button class="btn btn-outline-secondary pres-fit" data-fit="page" title="Fit page"><i class="bi bi-aspect-ratio"></i></button>
            </div>
            <div class="ms-2 small text-body-secondary"><span class="pres-page-label">Page</span> <input type="number" class="form-control form-control-sm d-inline-block pres-page-input" style="width:80px" min="1" value="1"> <span class="pres-pages-total"></span></div>
        
          </div>
          <div class="presentation-viewer-wrap position-relative border rounded bg-body-tertiary" style="min-height:240px;">
            <div class="presentation-placeholder small text-body-secondary p-3">$${'{'}(() => {
              if (mode === 'slideshow') return (data.document||data.document_id) ? 'Loading document…' : 'No document selected. Organizer can configure one in the plan.';
              if (hasShortlistPdf) return 'Loading shortlist PDF…';
              if (hasActionPlanPdf) return 'Loading action plan PDF…';
              return 'Loading…';
            })()${'}'}</div>
          </div>`;
        // Insert above the whiteboard in the Collaboration Panel
        const collabBody = elements.stickyBoard ? elements.stickyBoard.parentElement : null;
        if (collabBody) {
          collabBody.insertBefore(box, collabBody.firstChild);
        } else {
          elements.taskBody.appendChild(box); // fallback
        }
        // Render document inline if provided; for generated artifacts build a synthetic document
        let d = null;
        if (mode === 'slideshow') {
          d = data.document || (data.document_id ? { id: data.document_id, file_name: 'document.pdf', title: '', url: (data.document_url || `/document/file/${data.document_id}`) } : null);
        } else if (hasShortlistPdf) {
          d = { id: 'shortlist', file_name: 'shortlist.pdf', title: 'Shortlist', url: data.shortlist_pdf_url };
        } else if (hasActionPlanPdf) {
          d = { id: 'action_plan', file_name: 'action-plan.pdf', title: 'Action Plan', url: data.action_plan_pdf_url };
        }
        const wrap = box.querySelector('.presentation-viewer-wrap');
  const ctrls = box.querySelector('.presentation-controls');
        const pageInput = box.querySelector('.pres-page-input');
        const pagesTotal = box.querySelector('.pres-pages-total');
  const canControl = (isOrganizer || (data && data.presenter_user_id && Number(data.presenter_user_id) === Number(userId)));
  if (!canControl) { ctrls.querySelectorAll('button,input').forEach(el => el.disabled = true); }
        if (d && d.url && wrap) {
          const lower = (d.file_name || '').toLowerCase();
          const isPdf = lower.endsWith('.pdf');
          wrap.innerHTML = '';

          // Create canvas-based viewer (prefer PDF.js) with fallback to iframe
          const canvas = document.createElement('canvas');
          canvas.className = 'rounded bg-white';
          const ctx = canvas.getContext('2d', { alpha: false });
          const ph = document.createElement('div');
          ph.className = 'small text-body-secondary p-2';
          ph.textContent = 'Loading PDF…';
          wrap.appendChild(ph);
          wrap.appendChild(canvas);

          const storageKey = `ws:${workshopId}:pres:${data.task_id || 't'}`;
          const state = (() => { try { return JSON.parse(localStorage.getItem(storageKey) || '{}'); } catch(_) { return {}; } })();
          let currentPage = Math.max(1, parseInt(state.page || data.initial_slide_index || 1, 10) || 1);
          let currentZoom = Math.max(0.25, Math.min(5.0, parseFloat(state.zoom || 1.0)));
          // Default to fit width unless user set otherwise
          let currentFit = (state.fit && (state.fit === 'none' || state.fit === 'page' || state.fit === 'width')) ? state.fit : 'width';
          let totalPages = 0;
          if (pageInput) pageInput.value = String(currentPage);
          if (pagesTotal) pagesTotal.textContent = '';

          function persist() {
            try { localStorage.setItem(storageKey, JSON.stringify({ page: currentPage, zoom: currentZoom, fit: currentFit })); } catch(_) {}
          }

          function broadcast(action, extra) {
            if (!canControl) return;
            try {
              socket.emit('presentation_control', {
                room: roomName,
                workshop_id: workshopId,
                user_id: userId,
                task_id: data.task_id,
                action,
                page: currentPage,
                zoom: currentZoom,
                fit: currentFit,
                ...(extra||{})
              });
            } catch(_) {}
          }

          function updatePageLabel() {
            if (pageInput) {
              pageInput.min = '1';
              if (totalPages > 0) pageInput.max = String(totalPages);
              pageInput.value = String(currentPage);
            }
            if (pagesTotal) pagesTotal.textContent = totalPages > 0 ? `/ ${totalPages}` : '';
          }

          // PDF.js dynamic loader
          function loadScript(src) {
            return new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = src; s.async = true; s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
            });
          }

          async function ensurePdfJs() {
            if (window.pdfjsLib && window.pdfjsLib.getDocument) return true;
            const base = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174';
            try {
              await loadScript(`${base}/pdf.min.js`);
              // worker
              window.pdfjsLib.GlobalWorkerOptions.workerSrc = `${base}/pdf.worker.min.js`;
              return true;
            } catch (e) {
              return false;
            }
          }

          let pdfDoc = null;
          let pending = false;

          function computeScaleForFit(viewport) {
            try {
              const availW = wrap.clientWidth || canvas.parentElement.clientWidth || viewport.width;
              const availH = Math.max(320, Math.round(window.innerHeight * 0.52));
              const scaleW = availW / viewport.width;
              const scaleH = availH / viewport.height;
              if (currentFit === 'page') return Math.min(scaleW, scaleH);
              if (currentFit === 'width') return scaleW;
              return currentZoom; // none or unknown
            } catch(_) { return currentZoom; }
          }

          let renderTask = null;

          async function renderPage() {
            if (!pdfDoc || !ctx) return;
            pending = true;
            try {
              if (renderTask && typeof renderTask.cancel === 'function') { try { renderTask.cancel(); } catch(_) {} }
              const page = await pdfDoc.getPage(currentPage);
              const rotation = (page.rotate || 0);
              let baseViewport = page.getViewport({ scale: 1.0, rotation });
              const scale = computeScaleForFit(baseViewport);
              const dpr = (window.devicePixelRatio || 1);
              const viewport = page.getViewport({ scale: scale * dpr, rotation });
              canvas.width = Math.floor(viewport.width);
              canvas.height = Math.floor(viewport.height);
              canvas.style.width = Math.floor(viewport.width / dpr) + 'px';
              canvas.style.height = Math.floor(viewport.height / dpr) + 'px';
              // Reset any transforms and clear
              ctx.setTransform(1,0,0,1,0,0);
              ctx.clearRect(0,0,canvas.width,canvas.height);
              ph.style.display = 'none';
              renderTask = page.render({ canvasContext: ctx, viewport });
              await renderTask.promise;
            } catch(_) {
              // fallback to iframe on render errors
              fallbackToIframe();
            } finally {
              pending = false;
            }
          }

          function fallbackToIframe() {
            try {
              wrap.innerHTML = '';
              const iframe = document.createElement('iframe');
              iframe.src = d.url + '#toolbar=0&navpanes=0&scrollbar=1';
              iframe.title = 'PDF Viewer';
              iframe.style.width = '100%';
              iframe.style.height = '52vh';
              iframe.className = 'border-0 rounded presentation-iframe';
              wrap.appendChild(iframe);
            } catch(_) {}
          }

          (async () => {
            if (!isPdf) { fallbackToIframe(); return; }
            const ok = await ensurePdfJs();
            if (!ok) { fallbackToIframe(); return; }
            try {
              const l = document.createElement('div'); l.className = 'small text-body-secondary p-2'; l.textContent = 'Loading…'; wrap.insertBefore(l, canvas);
              const doc = await window.pdfjsLib.getDocument({ url: d.url }).promise;
              pdfDoc = doc;
              totalPages = doc.numPages || 0;
              l.remove();
              // Download button already wired above; keep visible
              updatePageLabel();
              await renderPage();
              // Update page-count badges beside Open/Download buttons
              try {
                const kind = d.id === 'shortlist' ? 'shortlist' : (d.id === 'action_plan' ? 'action_plan' : null);
                if (kind) {
                  document.querySelectorAll(`.pdf-pages-badge[data-kind="${kind}"]`).forEach(el => {
                    el.textContent = `${totalPages} page${totalPages===1?'':'s'}`;
                    el.classList.remove('d-none');
                  });
                }
              } catch(_) {}
            } catch(_) {
              fallbackToIframe();
            }
          })();

          // Controls wiring
          const btnPrev = box.querySelector('.pres-prev');
          const btnNext = box.querySelector('.pres-next');
          const btnZoomIn = box.querySelector('.pres-zoom-in');
          const btnZoomOut = box.querySelector('.pres-zoom-out');
          const btnFits = box.querySelectorAll('.pres-fit');
          if (btnPrev) btnPrev.addEventListener('click', async () => {
            if (!canControl) return; if (pending) return;
            currentPage = Math.max(1, currentPage - 1);
            updatePageLabel(); persist(); broadcast('goto'); await renderPage();
          });
          if (btnNext) btnNext.addEventListener('click', async () => {
            if (!canControl) return; if (pending) return;
            currentPage = Math.min(totalPages || (currentPage+1), currentPage + 1);
            updatePageLabel(); persist(); broadcast('goto'); await renderPage();
          });
          if (btnZoomIn) btnZoomIn.addEventListener('click', async () => {
            if (!canControl) return; if (pending) return;
            currentZoom = Math.min(5.0, (currentZoom + 0.1)); currentFit = 'none';
            persist(); broadcast('zoom'); await renderPage();
          });
          if (btnZoomOut) btnZoomOut.addEventListener('click', async () => {
            if (!canControl) return; if (pending) return;
            currentZoom = Math.max(0.25, (currentZoom - 0.1)); currentFit = 'none';
            persist(); broadcast('zoom'); await renderPage();
          });
          btnFits.forEach(btn => btn.addEventListener('click', async (e) => {
            if (!canControl) return; if (pending) return;
            const t=e.currentTarget; currentFit = t?.getAttribute('data-fit')||'page';
            persist(); broadcast('fit'); await renderPage();
          }));
          if (pageInput) pageInput.addEventListener('change', async () => {
            if (!canControl) return; if (pending) return;
            const n = parseInt(pageInput.value||'1',10)||1; currentPage = Math.max(1, Math.min(totalPages||n, n));
            updatePageLabel(); persist(); broadcast('goto'); await renderPage();
          });

          // Respond to incoming sync
          socket.off('presentation_sync');
          socket.on('presentation_sync', async (m) => {
            try {
              if (!m || m.workshop_id !== workshopId || m.task_id !== data.task_id) return;
              if (m.page) currentPage = Math.max(1, parseInt(m.page,10)||1);
              if (m.zoom) currentZoom = Math.max(0.25, Math.min(5.0, parseFloat(m.zoom)));
              if (m.fit) currentFit = String(m.fit);
              updatePageLabel(); persist(); await renderPage();
            } catch(err) {
              if (!String(err && err.name).includes('RenderingCancelledException')) {
                // Optional: console.debug('presentation_sync render error', err);
              }
            }
          });

          // Handle resize for fit modes
          try {
            let rid = null;
            const ro = new ResizeObserver(() => {
              if (currentFit === 'none') return;
              if (rid) cancelAnimationFrame(rid);
              rid = requestAnimationFrame(() => { renderPage(); });
            });
            ro.observe(wrap);
          } catch(_) { /* no-op */ }
        }
      } catch(_) {}
      // Auto-open Transcript pane and auto-play facilitator voice when shortlisting starts
      try {
        if (mode === 'shortlisting') {
          const tabBtn = document.getElementById('transcript-tab');
          if (tabBtn) {
            try {
              const Tab = bootstrap.Tab || (bootstrap && bootstrap.Tab);
              if (Tab) { Tab.getOrCreateInstance(tabBtn).show(); }
              else { tabBtn.click(); }
            } catch(_) { tabBtn.click(); }
            try { sessionStorage.setItem(`ws:${workshopId}:paneTab`, 'transcript'); } catch(_) {}
          }
          const auto = !!(window.ttsDefaults && window.ttsDefaults.autoread);
          if (auto && window.FacilitatorTTS) {
            // For shortlisting (a results_* phase), only use the LLM-provided tts_script
            const scriptText = (data.tts_script || '').toString();
            if (scriptText.trim().length > 0) {
              setTimeout(() => { try { if (!window.FacilitatorTTS.isSpeaking()) window.FacilitatorTTS.playSpeech(); } catch(_) {} }, 150);
            }
          }
        }
      } catch(_) {}

      // Impact–Effort chart: show during shortlisting when data contains coordinates
      try {
        if (mode === 'shortlisting') {
          const items = Array.isArray(data.prioritized) ? data.prioritized : (Array.isArray(data.shortlist) ? data.shortlist : []);
          const haveCoords = items.some(it => it && (it.impact != null || (it.scores && (it.scores.impact != null))) && (it.effort != null || (it.scores && (it.scores.effort != null))));
          if (haveCoords) {
            // Mount a canvas in the Collaboration Panel
            const collabBody = elements.stickyBoard ? elements.stickyBoard.parentElement : null;
            const chartWrap = document.createElement('div');
            chartWrap.className = 'border rounded p-2 bg-body-tertiary mt-2';
            chartWrap.innerHTML = `
              <div class="d-flex align-items-center gap-2 mb-2 small"><i class="bi bi-graph-up text-success"></i><span class="fw-semibold">Impact–Effort Matrix</span></div>
              <canvas id="impact-effort-canvas" height="260" class="w-100 rounded bg-white"></canvas>`;
            if (collabBody) {
              // Insert after the presentation viewer if present, else at top
              const viewer = document.querySelector('.presentation-viewer-box');
              if (viewer && viewer.nextSibling) collabBody.insertBefore(chartWrap, viewer.nextSibling);
              else collabBody.insertBefore(chartWrap, collabBody.firstChild);
            } else {
              elements.taskBody.appendChild(chartWrap);
            }
            renderImpactEffortChart('impact-effort-canvas', items);
          }
        }
      } catch(_) {}
    } else if (currentTaskType === 'results_prioritization') {
      elements.taskBody.innerHTML = `
        <p class="fs-5 mb-2">${description || 'Review the prioritized shortlist:'}</p>
        <p class="mb-1"><strong>Instructions:</strong></p>
        <p>${instructions || 'Discuss and confirm together.'}</p>`;
      // Dev banner for LLM failures if llm_error is present
      try {
        if (data && data.llm_error) {
          const warn = document.createElement('div');
          warn.className = 'alert alert-warning py-2 px-3 small';
          const exJson = (document.getElementById('llm-schema-examples')?.textContent || '{}');
          let ex = {};
          try { ex = JSON.parse(exJson)?.prioritization || {}; } catch(_) {}
          const exStr = (() => { try { return JSON.stringify(ex, null, 2); } catch(_) { return ''; } })();
          warn.innerHTML = `
            <div class="d-flex justify-content-between align-items-start gap-2">
              <div>
                <strong>LLM Error:</strong> ${String(data.llm_error)}
                <div class="text-muted">Strict mode requires an LLM response matching the schema.</div>
              </div>
              <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#llm-ex-prioritization" aria-expanded="false">Schema example</button>
            </div>
            <div class="collapse mt-2" id="llm-ex-prioritization">
              <pre class="mb-0 small bg-body-tertiary p-2 rounded"><code>${exStr.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</code></pre>
            </div>`;
          elements.taskBody.prepend(warn);
        }
      } catch(_) {}
      elements.leftColumnTitle.textContent = 'Shortlist';
      // Show LLM rationale next to shortlist. Default: organizers only; toggleable to all via UI switch.
      try {
        let rationale = '';
        if (data && data.rationale) {
          if (typeof data.rationale === 'string') {
            rationale = data.rationale;
          } else if (typeof data.rationale === 'object') {
            rationale = String(data.rationale.method || data.rationale.text || data.rationale.summary || '');
          }
        }
        const container = document.createElement('div');
        container.className = 'mt-2 shortlist-rationale-block';
        // Determine visibility: organizers always see it; participants only if organizer enabled the flag
        let visibleToAll = false;
        try {
          visibleToAll = JSON.parse(sessionStorage.getItem(`ws:${workshopId}:showRationaleAll`) || 'false');
        } catch(_) { visibleToAll = false; }
        const shouldShow = (isOrganizer || !!visibleToAll) && rationale && rationale.trim().length > 0;
        if (shouldShow) {
          const toggleId = 'rationale-toggle-' + String(data.task_id || 't');
          container.innerHTML = `
            <div class="d-flex align-items-center gap-2 small">
              <span class="badge text-bg-info"><i class="bi bi-lightbulb"></i> Rationale</span>
              ${isOrganizer ? `<div class="form-check form-switch ms-1">
                <input class="form-check-input" type="checkbox" id="${toggleId}" aria-label="Show to participants">
                <label class="form-check-label" for="${toggleId}">Show to all participants</label>
              </div>` : ''}
            </div>
            <div class="mt-1 small" data-role="rationale-text"></div>`;
          elements.taskBody.appendChild(container);
          const textEl = container.querySelector('[data-role="rationale-text"]');
          if (textEl) {
            const safe = rationale.replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>');
            textEl.innerHTML = safe;
          }
          if (isOrganizer) {
            const cb = container.querySelector('#' + toggleId);
            if (cb) {
              cb.addEventListener('change', (e) => {
                const checked = !!e.currentTarget.checked;
                try { sessionStorage.setItem(`ws:${workshopId}:showRationaleAll`, JSON.stringify(checked)); } catch(_) {}
                // Broadcast a lightweight UI hint to other clients (optional)
                try {
                  socket.emit('ui_hint', { room: roomName, workshop_id: workshopId, user_id: userId, key: 'showRationaleAll', value: checked });
                } catch(_) {}
              });
              try {
                const saved = JSON.parse(sessionStorage.getItem(`ws:${workshopId}:showRationaleAll`) || 'false');
                cb.checked = !!saved;
              } catch(_) {}
            }
          }
        }
      } catch(_) {}
      const pdfUrl = data.shortlist_pdf_url;
      if (pdfUrl) {
        elements.reportArea.innerHTML = '';
        show(elements.reportArea);
        window.ResultsViewer.injectPdfLinks(elements.reportArea, { pdfUrl, kind: 'shortlist', openText: 'Open PDF' });
        try { document.querySelectorAll('.presentation-viewer-box').forEach(n => n.remove()); } catch(_) {}
        const collabBody = elements.stickyBoard ? elements.stickyBoard.parentElement : null;
        const targetContainer = collabBody || elements.taskBody;
        const canControl = !!(isOrganizer || (data && data.presenter_user_id && Number(data.presenter_user_id) === Number(userId)));
        window.ResultsViewer.mountViewer({
          containerEl: targetContainer,
          pdfUrl,
          kind: 'shortlist',
          taskId: data.task_id,
          canControl,
          socket,
          roomName,
          workshopId,
          userId,
          controlEvent: 'prioritization_control',
          syncEvent: 'prioritization_sync',
          roleNoteText: 'Shortlist'
        });
      }
    } else if (currentTaskType === 'results_action_plan') {
      elements.taskBody.innerHTML = `
        <p class="fs-5 mb-2">${description || 'Review the action plan:'}</p>
        <p class="mb-1"><strong>Instructions:</strong></p>
        <p>${instructions || 'Walk through items, confirm owners and dates.'}</p>`;
      // Dev banner for LLM failures if llm_error is present
      try {
        if (data && data.llm_error) {
          const warn = document.createElement('div');
          warn.className = 'alert alert-warning py-2 px-3 small';
          const exJson = (document.getElementById('llm-schema-examples')?.textContent || '{}');
          let ex = {};
          try { ex = JSON.parse(exJson)?.action_plan || {}; } catch(_) {}
          const exStr = (() => { try { return JSON.stringify(ex, null, 2); } catch(_) { return ''; } })();
          warn.innerHTML = `
            <div class="d-flex justify-content-between align-items-start gap-2">
              <div>
                <strong>LLM Error:</strong> ${String(data.llm_error)}
                <div class="text-muted">Strict mode requires an LLM response matching the schema.</div>
              </div>
              <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#llm-ex-action-plan" aria-expanded="false">Schema example</button>
            </div>
            <div class="collapse mt-2" id="llm-ex-action-plan">
              <pre class="mb-0 small bg-body-tertiary p-2 rounded"><code>${exStr.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</code></pre>
            </div>`;
          elements.taskBody.prepend(warn);
        }
      } catch(_) {}
      elements.leftColumnTitle.textContent = 'Action Plan';
      const pdfUrl = data.action_plan_pdf_url;
      if (pdfUrl) {
        elements.reportArea.innerHTML = '';
        show(elements.reportArea);
        window.ResultsViewer.injectPdfLinks(elements.reportArea, { pdfUrl, kind: 'action_plan', openText: 'Open PDF' });
        try { document.querySelectorAll('.presentation-viewer-box').forEach(n => n.remove()); } catch(_) {}
        const collabBody = elements.stickyBoard ? elements.stickyBoard.parentElement : null;
        const targetContainer = collabBody || elements.taskBody;
        const canControl = !!(isOrganizer || (data && data.presenter_user_id && Number(data.presenter_user_id) === Number(userId)));
        window.ResultsViewer.mountViewer({
          containerEl: targetContainer,
          pdfUrl,
          kind: 'action_plan',
          taskId: data.task_id,
          canControl,
          socket,
          roomName,
          workshopId,
          userId,
          controlEvent: 'action_plan_control',
          syncEvent: 'action_plan_sync',
          roleNoteText: 'Action Plan'
        });
      }
    } else if (currentTaskType === 'framing') {
  const facPanel = facilitatorPanel;
      const genError = data.generation_error ? `<div class="alert alert-warning small mt-3" role="alert">${escapeHtml(data.generation_error)}</div>` : '';
      const problemText = facPanel.problem_statement || data.problem_statement || '';
      const successList = Array.isArray(facPanel.success_criteria) && facPanel.success_criteria.length
        ? facPanel.success_criteria
        : (Array.isArray(data.success_criteria) ? data.success_criteria : []);
      const contextSummary = data.context_summary || '';
      const keyInsights = Array.isArray(data.key_insights) ? data.key_insights : [];
      const participationNorms = Array.isArray(facPanel.participation_norms) ? facPanel.participation_norms : [];
      const agendaHighlights = Array.isArray(facPanel.agenda_highlights) ? facPanel.agenda_highlights : [];
      const unknowns = Array.isArray(facPanel.unknowns) ? facPanel.unknowns : [];
      const warmupSegue = facPanel.warmup_segue || '';
      const warmupInstruction = facPanel.warmup_instruction || '';

      const problemBlock = renderSection(
        'Problem statement',
        problemText
          ? `<p class="mb-0">${escapeHtml(problemText)}</p>`
          : '<p class="text-muted small mb-0">Not provided.</p>'
      );

      const contextBlock = contextSummary
        ? renderSection('Context', `<p class="mb-0">${escapeHtml(contextSummary)}</p>`)
        : '';

      const successBlock = successList.length
        ? renderListSection('Success criteria', successList)
        : renderSection('Success criteria', '<p class="text-muted small mb-0">Not provided.</p>');
      const insightsBlock = renderListSection('Key insights', keyInsights);
      const normsBlock = renderListSection('Participation norms', participationNorms);
      const agendaBlock = renderListSection('Agenda highlights', agendaHighlights);
      const unknownsBlock = renderListSection('Unknowns', unknowns);
      const warmupBlock = (warmupSegue || warmupInstruction)
        ? renderSection(
            'Warm-up prompt',
            `${warmupSegue ? `<p class="mb-1">${escapeHtml(warmupSegue)}</p>` : ''}${warmupInstruction ? `<p class="mb-0 fw-semibold">${escapeHtml(warmupInstruction)}</p>` : ''}`
          )
        : '';

      elements.taskBody.innerHTML = [
        problemBlock,
        successBlock,
        contextBlock,
        insightsBlock,
        normsBlock,
        // warmupBlock,
        agendaBlock,
        // unknownsBlock,
        genError || '',
      ].filter(Boolean).join('');
      elements.leftColumnTitle.textContent = 'Framing Brief';
      const pdfUrl = data.framing_pdf_url || data.pdf_document || (data.framing_document && data.framing_document.url) || (data.document && data.document.url);
      if (pdfUrl) {
        elements.reportArea.innerHTML = '';
        show(elements.reportArea);
        window.ResultsViewer.injectPdfLinks(elements.reportArea, { pdfUrl, kind: 'framing', openText: 'Open framing brief' });
        try { document.querySelectorAll('.presentation-viewer-box').forEach(n => n.remove()); } catch(_) {}
        const collabBody = elements.stickyBoard ? elements.stickyBoard.parentElement : null;
        const targetContainer = collabBody || elements.taskBody;
        window.ResultsViewer.mountViewer({
          containerEl: targetContainer,
          pdfUrl,
          kind: 'framing',
          taskId: data.task_id,
          canControl: true,
          socket,
          roomName,
          workshopId,
          userId,
          roleNoteText: 'Framing Brief'
        });
      } else {
        elements.reportArea.innerHTML = '<p class="text-muted small mb-0">Framing brief PDF unavailable.</p>';
        show(elements.reportArea);
      }
      try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
      ensureConferenceAutoStartIfEnabled();
    } else if (currentTaskType === 'speech') {
      // Minimal speech phase rendering; emphasize captions if cc_enabled
      const ccOn = (typeof data.cc_enabled === 'boolean') ? data.cc_enabled : true;
      const speakerIdNum = (data && data.speaker_user_id != null) ? Number(data.speaker_user_id) : null;
      const speakerName = (data && data.speaker_name) ? String(data.speaker_name) : (speakerIdNum != null ? `User #${speakerIdNum}` : null);
      elements.taskBody.innerHTML = `
        <p class="fs-5 mb-2">${description || 'A participant will deliver a short speech.'}</p>
        <p class="mb-1"><strong>Instructions:</strong></p>
        <p>${instructions || 'Please listen. Use chat to capture questions for later.'}</p>
        <ul class="small">
          ${speakerIdNum != null ? `<li><strong>Speaker:</strong> ${speakerName}</li>` : ''}
          <li><strong>Captions:</strong> ${ccOn ? 'Enabled' : 'Off'}</li>
        </ul>`;
      // Large speaker preview inside the Collaboration Panel (Speech box), not the AI Facilitator card
      try {
        // Remove any existing speech spotlight box to avoid duplicates when re-rendering
        document.querySelectorAll('.speech-spotlight-box').forEach(n => n.remove());
        const box = document.createElement('div');
        box.className = 'speech-spotlight-box mt-2';
        box.innerHTML = `
          <div class="speech-video-wrap">
            <div class="speech-video-placeholder small text-body-secondary">Waiting for speaker video…</div>
          </div>`;
        // Mount into the Collaboration Panel card body (parent of sticky-board)
        const collabBody = elements.stickyBoard ? elements.stickyBoard.parentElement : null;
        if (collabBody) {
          collabBody.insertBefore(box, collabBody.firstChild);
        } else {
          // Fallback: append to task body if structure changes unexpectedly
          elements.taskBody.appendChild(box);
        }
      } catch(_) {}
      elements.leftColumnTitle.textContent = 'Speech';
      try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
      // Auto-start the conference for everyone when speech begins (if enabled)
      ensureConferenceAutoStartIfEnabled();
      // Spotlight the selected speaker's video tile if available
      try {
        // Feed participants to the video module for nicer labels
        if (Array.isArray(data.participants) && window.VideoConference && typeof window.VideoConference.setParticipants === 'function') {
          window.VideoConference.setParticipants(data.participants);
        }
        if (window.VideoConference && typeof window.VideoConference.setSpotlight === 'function') {
          if (speakerIdNum != null) {
            const connected = (typeof window.VideoConference.isInConference === 'function') ? window.VideoConference.isInConference(speakerIdNum) : true;
            if (connected) {
              window.VideoConference.setSpotlight(speakerIdNum);
            } else {
              // Speaker not connected: clear spotlight and show a toast; keep phase running
              try { if (typeof window.VideoConference.clearSpotlight === 'function') window.VideoConference.clearSpotlight(); } catch(_) {}
              const area = document.getElementById('notification-area');
              if (area) {
                const div = document.createElement('div');
                div.className = 'alert alert-warning alert-dismissible fade show shadow-sm';
                div.role = 'alert';
                const friendly = speakerName || `User #${speakerIdNum}`;
                div.innerHTML = `Speaker ${friendly} isn’t connected yet. We’ll spotlight them when they join.
                  <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
                area.appendChild(div);
                setTimeout(() => { try { const inst = bootstrap.Alert.getOrCreateInstance(div); inst.close(); } catch(_) {} }, 6000);
              }
              // Nudge the status line for clarity
              try {
                const st = document.getElementById('vc-status-line');
                if (st) st.textContent = 'Waiting for speaker to connect…';
              } catch(_) {}
            }
          } else {
            try { if (typeof window.VideoConference.clearSpotlight === 'function') window.VideoConference.clearSpotlight(); } catch(_) {}
          }
        } else {
          // Fallback: direct DOM manipulation if module not available
          const grid = document.getElementById('video-grid');
          if (grid) {
            grid.querySelectorAll('.video-tile.spotlight').forEach(t => t.classList.remove('spotlight'));
            if (speakerIdNum != null) {
              const tile = grid.querySelector(`[data-remote="${speakerIdNum}"]`) || grid.querySelector('[data-tile="local"]');
              if (tile) {
                tile.classList.add('spotlight');
                try { tile.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' }); } catch(_) {}
              }
              // If remote tile missing, keep neutral and show a toast
              else {
                const area = document.getElementById('notification-area');
                if (area) {
                  const div = document.createElement('div');
                  div.className = 'alert alert-warning alert-dismissible fade show shadow-sm';
                  div.role = 'alert';
                  const friendly = speakerName || `User #${speakerIdNum}`;
                  div.innerHTML = `Speaker ${friendly} isn’t connected yet. We’ll spotlight them when they join.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
                  area.appendChild(div);
                  setTimeout(() => { try { const inst = bootstrap.Alert.getOrCreateInstance(div); inst.close(); } catch(_) {} }, 6000);
                }
              }
            }
          }
        }
      } catch(_) {}

      // Duplicate the speaker’s video into the Speech box (large preview)
      try {
        if (speakerIdNum != null) {
          const mount = (attemptsLeft = 20) => {
            if (currentTaskType !== 'speech') return; // phase changed
            const ok = (() => {
              const box = document.querySelector('.speech-spotlight-box');
              if (!box) return false;
              const wrap = box.querySelector('.speech-video-wrap');
              if (!wrap) return false;
              const grid = document.getElementById('video-grid');
              let sourceVideo = null;
              if (String(speakerIdNum) === String(userId)) {
                sourceVideo = document.getElementById('vc-local-video');
              } else {
                const tile = grid ? grid.querySelector(`[data-remote="${speakerIdNum}"]`) : null;
                sourceVideo = tile ? tile.querySelector('video') : null;
              }
              if (!sourceVideo || !sourceVideo.srcObject) return false;
              let dest = document.getElementById('speech-video-el');
              if (!dest) {
                dest = document.createElement('video');
                dest.id = 'speech-video-el';
                dest.autoplay = true; dest.playsInline = true;
                dest.muted = true; // always mute duplicated preview to avoid echo
                dest.className = 'w-100 h-100 object-fit-cover rounded';
                // Speaker badge
                const badge = document.createElement('span');
                badge.className = 'badge bg-warning text-dark position-absolute top-0 end-0 m-2';
                badge.textContent = 'Speaker';
                wrap.innerHTML = '';
                wrap.appendChild(badge);
                wrap.appendChild(dest);
              }
              if (dest.srcObject !== sourceVideo.srcObject) dest.srcObject = sourceVideo.srcObject;
              const ph = wrap.querySelector('.speech-video-placeholder'); if (ph) ph.remove();
              box.classList.add('ready');
              return true;
            })();
            if (!ok && attemptsLeft > 0) {
              setTimeout(() => mount(attemptsLeft - 1), 500);
            }
          };
          mount();
        }
      } catch(_) {}
  } else if (currentTaskType === 'vote_generic') {
      // Interactive generic voting: move list into the Whiteboard area
      const items = Array.isArray(data.items) ? data.items : [];
      const intro = description || 'Cast your dots on the items below.';
      const instr = instructions || `Use your dots to vote. You have ${userDots} dots remaining.`;
      // Keep AI Facilitator focused on announcements/instructions only
      elements.taskBody.innerHTML = `
        <p class=\"fs-5 mb-2\">${intro}</p>
        <p class=\"mb-1\"><strong>Instructions:</strong></p>
        <p>${instr}</p>`;
      // Update Whiteboard header to reflect activity title
      elements.leftColumnTitle.textContent = (data.title || 'Voting');
      // Show and sync dots; render into the dedicated generic voting area
      show(elements.userDotsDisplay);
      show(elements.genericVotingArea);
      if (data.participants_dots && data.participants_dots[userId] !== undefined) {
        updateUserDots(data.participants_dots[userId]);
      }
      renderGenericVoting(items);
      try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
  } else if (currentTaskType === 'summary') {
    // Do not repeat the title here; show description/instructions only to avoid duplicate headings
    elements.taskBody.innerHTML = `
      <p class="fs-5 mb-2">${description || ''}</p>
      <p class="mb-1"><strong>Instructions:</strong></p>
      <p>${instructions || 'Thank you for your participation!'}</p>`;
    elements.leftColumnTitle.textContent = "Workshop Summary";
  show(elements.reportArea);
    try {
      renderSummaryExperience(elements.reportArea, data, {
        socket,
        roomName,
        workshopId,
        userId,
        isOrganizer: !!isOrganizer
      });
    } catch (err) {
      console.warn('Summary rendering failed', err);
      try {
        const s = (data.summary_report || '').toString();
        if (s && s.trim().length > 0) {
          if (window.marked && typeof window.marked.parse === 'function') {
            elements.reportArea.innerHTML = window.marked.parse(s);
          } else {
            const safe = s.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
            elements.reportArea.innerHTML = `<div class="small">${safe}</div>`;
          }
        } else {
          elements.reportArea.innerHTML = '<p class="text-muted">No summary available.</p>';
        }
      } catch (_) {
        elements.reportArea.innerHTML = '<p class="text-muted">No summary available.</p>';
      }
    }
    // Use centralized scope switcher to avoid duplicate join_room emits
  try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
  } else {
        // Fallback for unknown type
        elements.taskBody.innerHTML = `<p>${description || 'Task details unavailable.'}</p><p>${instructions}</p>`;
  elements.leftColumnTitle.textContent = "Task Area";
  try { setChatScopeDefaultIfUnset('workshop_chat'); } catch(_) {}
    }

    // Initialize facilitator voice controller for ALL phases (one place).
    // For results_* phases, only use data.tts_script (no narration/instructions fallback).
    // For non-results phases, continue to allow narration/script fallbacks so play controls are usable.
    try {
      const isResultsPhase = (currentTaskType || '').startsWith('results_');
      let scriptText = '';
      if (isResultsPhase) {
        scriptText = (data.tts_script || '').toString();
      } else {
        scriptText = (
          data.tts_script ||
          data.narration ||
          data.summary_tts_script ||
          data.script ||
          data.instructions ||
          ''
        ).toString();
      }
      if (window.FacilitatorTTS) {
        const opts = (window.ttsDefaults || {});
        // Respect workshop default (now default-ON) and controller’s once-per-task gating
        window.FacilitatorTTS.initForTask(currentTaskId, scriptText, opts);
      }
    } catch (e) { console.warn('FacilitatorTTS init error', e); }

  // --- Auto-read handled within FacilitatorTTS.initForTask (once per task) ---
  try { /* handled in controller */ } catch (_) {}





    // --- Manage Input Form and Organizer Buttons ---
    const isPaused = workshopStatus === 'paused';
    const ideaInputActive = currentTaskType === 'warm-up' || currentTaskType === 'brainstorming';

    elements.ideaInput.value = ''; // Clear previous input


  if (ideaInputActive) { show(elements.ideaFormContainer); } else { hide(elements.ideaFormContainer); }
    elements.ideaSubmitBtn.disabled = isPaused || !ideaInputActive;
    elements.ideaInput.disabled = isPaused || !ideaInputActive;

    // --- Manage Organizer Buttons ---
    if (isOrganizer) {
  // Disable "Next Task" button until timer finishes
    if (elements.nextTaskBtn) {
      elements.nextTaskBtn.disabled = true;
      elements.nextTaskBtn.classList.remove('d-none');
    }
  // Show Prev/End controls during an active task
  if (elements.prevTaskBtn) elements.prevTaskBtn.classList.remove('d-none');
  if (elements.endTaskBtn) elements.endTaskBtn.classList.remove('d-none');
        // Hide "Begin Workshop" button if it exists
        if (elements.beginIntroForm) {
            if (elements.beginIntroForm) elements.beginIntroForm.classList.add('d-none');
        }
  // Ensure Prev reflects first-phase state
  updatePrevNextDisabled();
    }




  // --- Start timer ---
  startOrSyncCountdown(totalDurationForCurrentTask, totalDurationForCurrentTask);
  }

  function renderSummaryExperience(container, data, context) {
    if (!container) return;
    const { socket, roomName, workshopId, userId, isOrganizer } = context || {};
    const uniqueId = `summary-${data.task_id || Date.now()}`;
    const canonical = normalizeCanonicalSession(data.canonical_session_json);
    const { metricsCardsHtml, pulseHtml, topClusters } = buildSummaryInsights(canonical);
    const hasMarkdown = typeof data.summary_report === 'string' && data.summary_report.trim().length > 0;
    const hasPdf = typeof data.summary_pdf_url === 'string' && data.summary_pdf_url.trim().length > 0;
    const hasPptx = typeof data.summary_pptx_url === 'string' && data.summary_pptx_url.trim().length > 0;
    let slidesSpec = (data.artifacts && data.artifacts.slides_spec) ? data.artifacts.slides_spec : null;
    if (slidesSpec && typeof slidesSpec === 'string') {
      try { slidesSpec = JSON.parse(slidesSpec); } catch (_) { slidesSpec = null; }
    }

    container.innerHTML = `
      <div class="summary-experience card border-0 shadow-sm overflow-hidden">
        <div class="summary-experience__glow"></div>
        <div class="card-body p-4 p-lg-5">
          <div class="d-flex flex-column flex-lg-row align-items-lg-end gap-4 mb-4">
            <div class="flex-grow-1">
              <h2 class="h4 mb-2">Executive Wrap-Up</h2>
              <p class="text-body-secondary mb-0">Everything the team produced—rendered as a living brief, a polished report, and a slide-ready storyline.</p>
            </div>
            <div class="summary-insights__pulse d-flex align-items-center gap-3">
              ${pulseHtml}
            </div>
          </div>
          <div class="summary-insights__cards mb-4">
            ${metricsCardsHtml}
          </div>
          <ul class="nav nav-pills summary-tabs mb-3" id="${uniqueId}-tabs" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="${uniqueId}-brief-tab" data-bs-toggle="pill" data-bs-target="#${uniqueId}-brief" type="button" role="tab">Executive Brief</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="${uniqueId}-pdf-tab" data-bs-toggle="pill" data-bs-target="#${uniqueId}-pdf" type="button" role="tab">Report PDF</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="${uniqueId}-slides-tab" data-bs-toggle="pill" data-bs-target="#${uniqueId}-slides" type="button" role="tab">Slide Studio</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="${uniqueId}-dna-tab" data-bs-toggle="pill" data-bs-target="#${uniqueId}-dna" type="button" role="tab">Session DNA</button>
            </li>
          </ul>
          <div class="tab-content" id="${uniqueId}-content">
            <div class="tab-pane fade show active" id="${uniqueId}-brief" role="tabpanel" aria-labelledby="${uniqueId}-brief-tab">
              <div class="summary-pane">
                <div data-summary-markdown class="summary-markdown"></div>
              </div>
            </div>
            <div class="tab-pane fade" id="${uniqueId}-pdf" role="tabpanel" aria-labelledby="${uniqueId}-pdf-tab">
              <div class="summary-pane">
                <div class="d-flex flex-wrap justify-content-between gap-2 align-items-center mb-3">
                  <div class="text-body-secondary">Interactive report powered by the LLM-authored document spec.</div>
                  <div class="summary-artifact-actions">
                    ${hasPdf ? `<a class="btn btn-sm btn-outline-primary" href="${data.summary_pdf_url}" target="_blank" rel="noopener">Open in new tab</a><a class="btn btn-sm btn-primary" href="${data.summary_pdf_url}" download>Download PDF</a>` : ''}
                  </div>
                </div>
                <div data-summary-pdf-wrap class="summary-pdf-viewer border rounded bg-white position-relative overflow-hidden">
                  <div class="summary-empty-state small text-body-secondary">${hasPdf ? 'Preparing embedded viewer…' : 'No PDF artifact was generated for this session.'}</div>
                </div>
              </div>
            </div>
            <div class="tab-pane fade" id="${uniqueId}-slides" role="tabpanel" aria-labelledby="${uniqueId}-slides-tab">
              <div class="summary-pane">
                <div class="d-flex flex-wrap justify-content-between align-items-center gap-2 mb-3">
                  <div class="text-body-secondary">Walk the storyline exactly as the facilitator composed it.</div>
                  <div class="summary-artifact-actions">
                    ${hasPptx ? `<a class="btn btn-sm btn-outline-primary" href="${data.summary_pptx_url}" target="_blank" rel="noopener">Download PPTX</a>` : ''}
                  </div>
                </div>
                <div data-summary-slides-wrap class="summary-slides"></div>
              </div>
            </div>
            <div class="tab-pane fade" id="${uniqueId}-dna" role="tabpanel" aria-labelledby="${uniqueId}-dna-tab">
              <div class="summary-pane">
                <div class="text-body-secondary small mb-3">A transparent view into the canonical session JSON that the LLM composed against.</div>
                <div data-summary-session-wrap class="summary-session-dna"></div>
              </div>
            </div>
          </div>
          ${topClusters.length ? `<div class="mt-4 summary-top-clusters">
            <h3 class="h6 text-uppercase small text-body-secondary mb-2">Momentum Clusters</h3>
            <div class="row g-3">${topClusters.map((cluster) => `
              <div class="col-12 col-lg-4">
                <div class="summary-cluster-card border rounded-3 p-3 h-100">
                  <div class="d-flex justify-content-between align-items-start mb-1">
                    <span class="badge rounded-pill text-bg-primary">${escapeHtml(cluster.votes_label)}</span>
                    <span class="summary-cluster-score fw-semibold">${escapeHtml(cluster.vote_count)}</span>
                  </div>
                  <div class="fw-semibold mb-1">${escapeHtml(cluster.label)}</div>
                  <div class="text-body-secondary small">${escapeHtml(cluster.caption)}</div>
                </div>
              </div>`).join('')}</div>
          </div>` : ''}
        </div>
      </div>`;

    const markdownTarget = container.querySelector('[data-summary-markdown]');
    if (markdownTarget) {
      if (hasMarkdown) {
        try {
          if (window.marked && typeof window.marked.parse === 'function') {
            markdownTarget.innerHTML = window.marked.parse(data.summary_report);
          } else {
            markdownTarget.innerHTML = `<div class="small">${escapeHtml(data.summary_report).replace(/\n/g, '<br>')}</div>`;
          }
        } catch (_) {
          markdownTarget.innerHTML = `<div class="small">${escapeHtml(data.summary_report || '').replace(/\n/g, '<br>')}</div>`;
        }
      } else {
        markdownTarget.innerHTML = '<p class="text-muted small">No executive brief was generated for this workshop.</p>';
      }
    }

    const pdfWrap = container.querySelector('[data-summary-pdf-wrap]');
    if (pdfWrap) {
      if (hasPdf && window.ResultsViewer && typeof window.ResultsViewer.mountViewer === 'function') {
        pdfWrap.innerHTML = '';
        window.ResultsViewer.mountViewer({
          containerEl: pdfWrap,
          pdfUrl: data.summary_pdf_url,
          kind: 'summary',
          taskId: data.task_id,
          canControl: !!isOrganizer,
          socket,
          roomName,
          workshopId,
          userId,
          controlEvent: 'summary_control',
          syncEvent: 'summary_sync',
          roleNoteText: 'Summary Report'
        });
      } else if (!hasPdf) {
        pdfWrap.innerHTML = '<p class="text-muted small mb-0">No PDF artifact available.</p>';
      }
    }

    const slidesWrap = container.querySelector('[data-summary-slides-wrap]');
    if (slidesWrap) {
      renderSlidesSpecPreview(slidesWrap, slidesSpec, hasPptx);
    }

    const sessionWrap = container.querySelector('[data-summary-session-wrap]');
    if (sessionWrap) {
      renderSessionDna(sessionWrap, canonical);
    }
  }

  function normalizeCanonicalSession(raw) {
    if (!raw) return {};
    if (typeof raw === 'object') return raw;
    if (typeof raw === 'string') {
      try {
        return JSON.parse(raw);
      } catch (_) {
        return {};
      }
    }
    return {};
  }

  function buildSummaryInsights(canonical) {
    const ideas = Array.isArray(canonical.ideas) ? canonical.ideas : [];
    const clusters = Array.isArray(canonical.clusters) ? canonical.clusters : [];
    const votes = Array.isArray(canonical.votes) ? canonical.votes : [];
    const chatEntries = Array.isArray(canonical.chat) ? canonical.chat : [];
    const transcriptEntries = Array.isArray(canonical.transcripts) ? canonical.transcripts : [];
    const overview = canonical.workshop_overview && typeof canonical.workshop_overview === 'object' ? canonical.workshop_overview : {};

    const participantsCount = (() => {
      if (Number.isFinite(Number(overview.participants_count))) return Number(overview.participants_count);
      if (Array.isArray(overview.participants)) return overview.participants.length;
      if (Array.isArray(overview.attendees)) return overview.attendees.length;
      return null;
    })();

    const votesMap = new Map();
    votes.forEach((entry) => {
      if (!entry) return;
      const id = entry.cluster_id ?? entry.id;
      const count = Number(entry.votes ?? entry.count ?? entry.value);
      if (id == null || !Number.isFinite(count)) return;
      votesMap.set(id, count);
    });

    const topClusters = clusters
      .map((cluster, index) => {
        const clusterId = cluster.cluster_id ?? cluster.id ?? index;
        const votesValue = votesMap.has(clusterId) ? votesMap.get(clusterId) : Number(cluster.votes);
        const name = cluster.title || cluster.label || cluster.theme || `Cluster ${index + 1}`;
        const captionSource = cluster.summary || cluster.description || cluster.problem || cluster.prompt || '';
        const caption = captionSource ? captionSource.toString() : 'Curated during clustering phase.';
        const voteCount = Number.isFinite(Number(votesValue)) ? Number(votesValue) : 0;
        return {
          id: clusterId,
          label: name,
          vote_count: voteCount.toString(),
          votes_label: voteCount === 1 ? '1 vote' : `${voteCount} votes`,
          caption,
        };
      })
      .sort((a, b) => Number(b.vote_count) - Number(a.vote_count))
      .slice(0, 3);

    const decisionCount = (() => {
      const actionPlan = canonical.action_plan;
      if (!actionPlan) return 0;
      if (Array.isArray(actionPlan)) return actionPlan.length;
      if (typeof actionPlan === 'object') {
        let total = 0;
        if (Array.isArray(actionPlan.actions)) total += actionPlan.actions.length;
        if (Array.isArray(actionPlan.decisions)) total += actionPlan.decisions.length;
        if (total === 0) {
          Object.values(actionPlan).forEach((value) => {
            if (Array.isArray(value)) total += value.length;
          });
        }
        if (Number.isFinite(Number(actionPlan.count))) {
          total = Math.max(total, Number(actionPlan.count));
        }
        return total;
      }
      if (Number.isFinite(Number(actionPlan))) return Number(actionPlan);
      return 0;
    })();

    const insightCards = [
      {
        label: 'Ideas Captured',
        value: ideas.length,
        accent: 'primary',
        hint: 'Unique contributions recorded during brainstorming.',
      },
      {
        label: 'Clusters Formed',
        value: clusters.length,
        accent: 'success',
        hint: 'Themes distilled during clustering & voting.',
      },
      {
        label: 'Decisions Logged',
        value: decisionCount,
        accent: 'warning',
        hint: 'Action items & commitments captured in wrap-up.',
      },
      {
        label: 'Signals Exchanged',
        value: chatEntries.length + transcriptEntries.length,
        accent: 'info',
        hint: 'Chat + transcript entries across the session.',
      },
    ];

    if (participantsCount != null) {
      insightCards.unshift({
        label: 'Participants',
        value: participantsCount,
        accent: 'secondary',
        hint: 'Voices represented in the workshop.',
      });
    }

    const metricCards = insightCards
      .filter((card) => Number(card.value) > 0)
      .map((card) => `
        <div class="summary-metric">
          <div class="summary-metric__value summary-metric__value--${card.accent}">${escapeHtml(card.value.toString())}</div>
          <div class="summary-metric__label">${escapeHtml(card.label)}</div>
          <div class="summary-metric__hint text-body-secondary small">${escapeHtml(card.hint)}</div>
        </div>`);

    const metricsCardsHtml = metricCards.length
      ? metricCards.join('')
      : '<div class="summary-metric"><div class="summary-metric__value summary-metric__value--secondary">—</div><div class="summary-metric__label">Data in progress</div><div class="summary-metric__hint text-body-secondary small">Summary metrics will populate once the session captures more activity.</div></div>';

    const pulseHtml = (() => {
      const votePulse = votesMap.size ? `${votesMap.size} clusters received votes` : 'Momentum snapshot ready';
      const ideaPulse = ideas.length ? `${ideas.length} ideas synthesized` : 'Awaiting idea synthesis';
      return `<div class="summary-pulse">${escapeHtml(votePulse)}</div><div class="summary-pulse">${escapeHtml(ideaPulse)}</div>`;
    })();

    return {
      metricsCardsHtml,
      pulseHtml,
      topClusters,
    };
  }

  function renderSlidesSpecPreview(container, spec, hasDownload) {
    const fallback = '<p class="text-muted small mb-0">Slide narrative will appear here once generated.</p>';
    if (!spec || typeof spec !== 'object') {
      container.innerHTML = hasDownload ? fallback : '<p class="text-muted small mb-0">No slide deck was generated for this session.</p>';
      return;
    }
    const slides = Array.isArray(spec.slides) ? spec.slides : [];
    if (!slides.length) {
      container.innerHTML = hasDownload ? fallback : '<p class="text-muted small mb-0">No slide deck was generated for this session.</p>';
      return;
    }

    const cards = slides.map((slide, idx) => {
      const title = slide && slide.title ? escapeHtml(slide.title) : `Slide ${idx + 1}`;
      const layout = slide && slide.layout ? slide.layout.toString() : 'title+bullets';
      const bullets = Array.isArray(slide?.bullets) ? slide.bullets.slice(0, 4).map((b) => `<li>${escapeHtml(b)}</li>`).join('') : '';
      const hasTable = Array.isArray(slide?.rows) && slide.rows.length;
      const vibe = layout.includes('table') ? 'table' : layout.includes('image') ? 'image' : 'bullets';
      const meta = escapeHtml(vibe === 'bullets' ? 'Story beats' : vibe === 'table' ? 'Data frame' : 'Visual anchor');
      const body = bullets ? `<ul class="summary-slide-bullets">${bullets}</ul>` : (hasTable ? `<div class="summary-slide-table text-body-secondary small">${escapeHtml(`${slide.rows.length} rows × ${(slide.columns || []).length} cols`)}</div>` : '<div class="text-body-secondary small">Narrative cue captured.</div>');
      return `
        <div class="summary-slide-card">
          <div class="summary-slide-index">${idx + 1}</div>
          <div class="summary-slide-title">${title}</div>
          <div class="text-body-secondary small mb-2">${meta}</div>
          ${body}
        </div>`;
    }).join('');

    container.innerHTML = `<div class="summary-slide-grid">${cards}</div>`;
  }

  function renderSessionDna(container, canonical) {
    const sections = buildSessionTimeline(canonical);
    if (!sections.length) {
      container.innerHTML = '<p class="text-muted small mb-0">Canonical session JSON is not available for display.</p>';
      return;
    }
    container.innerHTML = `
      <div class="summary-session-timeline">
        ${sections.map((section) => `
          <div class="summary-session-timeline__item">
            <div class="summary-session-timeline__phase">${escapeHtml(section.label)}</div>
            <div class="summary-session-timeline__status ${section.active ? 'is-active' : ''}">${escapeHtml(section.status)}</div>
            <div class="summary-session-timeline__detail text-body-secondary small">${escapeHtml(section.detail)}</div>
          </div>`).join('')}
      </div>
      <details class="summary-json-dump">
        <summary class="small">Show raw canonical JSON</summary>
        <pre class="summary-json-pre">${escapeHtml(JSON.stringify(canonical, null, 2))}</pre>
      </details>`;
  }

  function buildSessionTimeline(canonical) {
    const template = [
      { key: 'framing', label: 'Framing' },
      { key: 'warmup', label: 'Warm-Up' },
      { key: 'brainstorming', label: 'Brainstorming' },
      { key: 'clustering_voting', label: 'Clustering & Voting' },
      { key: 'feasibility', label: 'Feasibility' },
      { key: 'prioritization', label: 'Prioritization' },
      { key: 'action_plan', label: 'Action Plan' },
      { key: 'discussion', label: 'Discussion' },
    ];

    return template.map((entry, index) => {
      const payload = canonical[entry.key];
      const status = describeSessionSection(payload);
      const isActive = status && !status.startsWith('No');
      return {
        label: entry.label,
        status: status || 'No data recorded',
        detail: summariseSessionPayload(payload),
        active: isActive,
        index,
      };
    });
  }

  function describeSessionSection(payload) {
    if (!payload) return 'No data recorded';
    if (Array.isArray(payload)) {
      if (!payload.length) return 'No entries recorded';
      return payload.length === 1 ? '1 entry captured' : `${payload.length} entries captured`;
    }
    if (typeof payload === 'object') {
      const keys = Object.keys(payload).filter((key) => payload[key] != null);
      if (!keys.length) return 'Structure stored';
      return `${keys.length} data points logged`;
    }
    return 'Data captured';
  }

  function summariseSessionPayload(payload) {
    if (!payload) return 'Awaiting contributions.';
    if (Array.isArray(payload)) {
      if (!payload.length) return 'Phase recorded without entries.';
      const first = payload[0];
      if (first && typeof first === 'object') {
        const sample = Object.values(first).find((v) => typeof v === 'string' && v.trim().length > 0);
        if (sample) return sample.length > 140 ? `${sample.slice(0, 137)}…` : sample;
      }
      if (typeof first === 'string') {
        return first.length > 140 ? `${first.slice(0, 137)}…` : first;
      }
      return `${payload.length} items captured.`;
    }
    if (typeof payload === 'object') {
      const textLike = Object.values(payload).find((v) => typeof v === 'string' && v.trim().length > 0);
      if (textLike) return textLike.length > 140 ? `${textLike.slice(0, 137)}…` : textLike;
      const arrays = Object.values(payload).filter(Array.isArray);
      if (arrays.length) return `${arrays.map((arr) => `${arr.length} items`).join(', ')} documented.`;
      return 'Structured insights captured.';
    }
    if (typeof payload === 'string') {
      return payload.length > 140 ? `${payload.slice(0, 137)}…` : payload;
    }
    return 'Structured insights captured.';
  }

  // Apply updated artifacts without changing phase
  function applyPresentationArtifactsUpdate(mode, artifacts, taskData) {
    try {
      if (!artifacts || !mode) return;
      // Update last payload and script for TTS controller
      try {
        if (window._lastTaskPayload) {
          if (artifacts.tts_script) window._lastTaskPayload.tts_script = artifacts.tts_script;
        }
        if (window.FacilitatorTTS && typeof window.FacilitatorTTS.initForTask === 'function') {
          const scriptText = (artifacts.tts_script || '').toString();
          if (scriptText) window.FacilitatorTTS.initForTask(currentTaskId, scriptText, (window.ttsDefaults||{}));
        }
      } catch(_) {}

      // Update shortlist or action plan summary list and links in the Task Body
      const body = elements.taskBody;
      if (!body) return;
      // Recreate the PDF viewer with the new URL
      document.querySelectorAll('.presentation-viewer-box').forEach(n => n.remove());

      if (mode === 'shortlisting') {
        // Update Shortlist count/list fragment if present
        // For simplicity, append/replace a new summary block
        const existing = body.querySelector('.shortlist-summary-block'); if (existing) existing.remove();
        const block = document.createElement('div');
        block.className = 'small mt-2 shortlist-summary-block';
        const sl = Array.isArray(artifacts.shortlist) ? artifacts.shortlist : [];
        block.innerHTML = `<strong>Shortlist (${sl.length}):</strong><ol class="mt-1">${sl.slice(0,10).map(it=>`<li>${String(it.label||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</li>`).join('')}</ol>`;
        body.appendChild(block);
        // Update link buttons
        if (artifacts.shortlist_pdf_url) {
          const links = document.createElement('div');
          links.className = 'mt-2 d-flex gap-2';
          links.innerHTML = `<a class="btn btn-sm btn-outline-primary" href="${artifacts.shortlist_pdf_url}" target="_blank" rel="noopener">Open shortlist PDF</a>
                             <a class="btn btn-sm btn-primary" href="${artifacts.shortlist_pdf_url}" download>Download</a>`;
          body.appendChild(links);
        }
        // Recreate viewer
        const fakeTask = Object.assign({}, taskData, { shortlist_pdf_url: artifacts.shortlist_pdf_url });
        // Re-enter the rendering branch to mount a fresh viewer
        try { window.setTimeout(() => { try { displayTask(Object.assign({}, window._lastTaskPayload, fakeTask)); } catch(_) {} }, 10); } catch(_) {}
      } else if (mode === 'action_plan') {
        // Update buttons
        if (artifacts.action_plan_pdf_url) {
          const links = document.createElement('div');
          links.className = 'mt-2 d-flex gap-2';
          links.innerHTML = `<a class="btn btn-sm btn-outline-primary" href="${artifacts.action_plan_pdf_url}" target="_blank" rel="noopener">Open action plan PDF</a>
                             <a class="btn btn-sm btn-primary" href="${artifacts.action_plan_pdf_url}" download>Download</a>`;
          body.appendChild(links);
        }
        const fakeTask = Object.assign({}, taskData, { action_plan_pdf_url: artifacts.action_plan_pdf_url });
        try { window.setTimeout(() => { try { displayTask(Object.assign({}, window._lastTaskPayload, fakeTask)); } catch(_) {} }, 10); } catch(_) {}
      }
    } catch (e) {
      console.warn('applyPresentationArtifactsUpdate error', e);
    }
  }

  // Draw a basic Impact–Effort matrix (0–100 scaled) with quadrant labels.
  function renderImpactEffortChart(canvasId, items) {
    try {
      const canvas = document.getElementById(canvasId);
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.clientWidth || canvas.width; const H = canvas.height;
      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Axes margins
      const L = 36, R = 16, T = 16, B = 36;
      const plotW = (canvas.width - L - R);
      const plotH = (H - T - B);
      // Draw border and grid
      ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
      ctx.strokeRect(L, T, plotW, plotH);
      // Midlines for quadrants
      ctx.beginPath();
      ctx.moveTo(L + plotW/2, T); ctx.lineTo(L + plotW/2, T + plotH);
      ctx.moveTo(L, T + plotH/2); ctx.lineTo(L + plotW, T + plotH/2);
      ctx.stroke();
      // Labels
      ctx.fillStyle = '#666'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillText('Low Effort', L + 4, H - 6);
      ctx.fillText('High Effort', L + plotW - 64, H - 6);
      ctx.save(); ctx.translate(6, T + 12); ctx.rotate(-Math.PI/2); ctx.fillText('Low Impact', 0, 0); ctx.restore();
      ctx.save(); ctx.translate(6, T + plotH - 4); ctx.rotate(-Math.PI/2); ctx.fillText('High Impact', 0, 0); ctx.restore();
      // Plot points
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const toX = (effort) => L + clamp(effort, 0, 100) * (plotW/100);
      const toY = (impact) => T + (100 - clamp(impact, 0, 100)) * (plotH/100);
      let colorIdx = 0; const colors = ['#0d6efd','#198754','#dc3545','#6f42c1','#fd7e14','#20c997'];
      items.forEach((it, idx) => {
        const label = (it.label || it.title || `#${idx+1}`).toString();
        const imp = (it.impact != null) ? Number(it.impact) : (it.scores && it.scores.impact != null ? Number(it.scores.impact) : null);
        const eff = (it.effort != null) ? Number(it.effort) : (it.scores && it.scores.effort != null ? Number(it.scores.effort) : null);
        if (imp == null || eff == null) return;
        const x = toX(eff*20 || eff); // if 1–5 scale, multiply by 20
        const y = toY(imp*20 || imp);
        const c = colors[colorIdx++ % colors.length];
        ctx.fillStyle = c; ctx.strokeStyle = c;
        ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
        // Label slightly offset
        ctx.fillStyle = '#333';
        ctx.fillText(label.slice(0, 24), x + 6, y - 6);
      });
    } catch (e) { console.warn('Impact–Effort chart error', e); }
  }

  function updatePrevNextDisabled() {
    if (!isOrganizer) return;
    const hasIndex = typeof currentTaskIndex === 'number' && currentTaskIndex >= 0;
    if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = !hasIndex || currentTaskIndex <= 0;
    if (elements.nextTaskBtn) elements.nextTaskBtn.disabled = !hasIndex ? elements.nextTaskBtn.disabled : elements.nextTaskBtn.disabled; // leave as-is until timer end
  }

  // --- Phase badge & Session Flow ---
  function updatePhaseUI(taskType, phaseContext) {
    try {
      const phaseMap = {
        'framing': 'Briefing',
        'warm-up': 'Warm-up',
        'warm_up': 'Warm-up',
        'introduction': 'Intro',
        'brainstorming': 'Ideas',
        'clustering_voting': 'Clustering',
        'results_feasibility': 'Feasibility',
        'results_prioritization': 'Prioritization',
        'results_action_plan': 'Action Plan',
        'discussion': 'Discussion',
        'summary': 'Summary'
      };

      const labelEl = document.getElementById('current-phase-label');
      if (labelEl) {
        const rawPhase = (typeof phaseContext === 'string') ? phaseContext.trim() : '';
        const firstLine = rawPhase ? rawPhase.split(/\r?\n/)[0].trim() : '';
  const cleaned = firstLine.replace(/^Phase:\s*/i, '').trim();
  const hasCleaned = cleaned && cleaned.toLowerCase() !== 'none';
  const friendly = hasCleaned ? cleaned : (phaseMap[taskType] || 'Phase');
        labelEl.textContent = friendly;
        labelEl.classList.remove('text-bg-secondary');
        labelEl.classList.add('text-bg-primary');
      }

      // Highlight current phase in Session Flow badges (dynamic badges with data-index)
      if (elements.sessionFlow) {
        elements.sessionFlow.querySelectorAll('.badge[data-index]')
          .forEach(b => {
            const idx = parseInt(b.getAttribute('data-index'));
            const isActive = (typeof currentTaskIndex === 'number') && idx === currentTaskIndex;
            b.classList.toggle('text-bg-primary', isActive);
            b.classList.toggle('text-bg-light', !isActive);
          });
      }
    } catch (e) {
      console.warn('updatePhaseUI error:', e);
    }
  }

  function resetPhaseUI() {
    const labelEl = document.getElementById('current-phase-label');
    if (labelEl) {
      labelEl.textContent = 'Phase';
      labelEl.classList.remove('text-bg-primary');
      if (!labelEl.classList.contains('text-bg-secondary')) labelEl.classList.add('text-bg-secondary');
    }
    if (elements.sessionFlow) {
      elements.sessionFlow.querySelectorAll('.badge[data-index]').forEach(b => {
        b.classList.remove('text-bg-primary');
        if (!b.classList.contains('text-bg-light')) b.classList.add('text-bg-light');
      });
    }
  }

  async function loadPlan() {
    try {
      const r = await fetch(`/workshop/${workshopId}/plan`, { headers: { 'X-Requested-With': 'XMLHttpRequest' }});
      const d = await r.json();
      planCache = { current_plan: Array.isArray(d.current_plan) ? d.current_plan : [] };
      renderSessionFlow();
    } catch (e) {
      console.warn('Failed to load plan:', e);
      planCache = { current_plan: [] };
      renderSessionFlow();
    }
  }

  function renderSessionFlow() {
    if (!elements.sessionFlow) return;
    const plan = (planCache && Array.isArray(planCache.current_plan)) ? planCache.current_plan : [];
    elements.sessionFlow.innerHTML = '';
    if (!plan.length) {
      elements.sessionFlow.innerHTML = '<span class="text-muted">No session plan</span>';
      return;
    }
    plan.forEach((node, idx) => {
      const label = ({
        'framing': 'Briefing',
        'warm-up': 'Warm-up',
        'warm_up': 'Warm-up',
        'introduction': 'Intro',
        'brainstorming': 'Ideas',
        'clustering_voting': 'Clustering',
        'results_feasibility': 'Feasibility',
        'results_prioritization': 'Prioritization',
        'results_action_plan': 'Action Plan',
        'discussion': 'Discussion',
        'summary': 'Summary'
      })[node.task_type] || node.task_type;
      const span = document.createElement('span');
      span.className = 'badge rounded-pill text-bg-light';
      span.dataset.index = String(idx);
      span.title = node.task_type;
      span.textContent = label + (countDuplicatesBefore(plan, node.task_type, idx) > 0 ? ` ${countDuplicatesBefore(plan, node.task_type, idx)+1}` : '');
      if (typeof currentTaskIndex === 'number' && idx === currentTaskIndex) {
        span.classList.remove('text-bg-light');
        span.classList.add('text-bg-primary');
      }
      if (isOrganizer) {
        span.style.cursor = 'pointer';
        span.addEventListener('click', () => jumpToIndex(idx));
      }
      elements.sessionFlow.appendChild(span);
    });
  }

  function countDuplicatesBefore(plan, type, upToIndex) {
    let count = 0;
    for (let i = 0; i < upToIndex; i++) {
      if (plan[i] && plan[i].task_type === type) count++;
    }
    return count;
  }

  async function jumpToIndex(idx) {
    if (!isOrganizer) return;
    try {
      const r = await fetch(`/workshop/${workshopId}/goto/${idx}`, { method: 'POST', headers: { 'X-Requested-With': 'XMLHttpRequest' }});
      const d = await r.json().catch(() => ({}));
      if (!r.ok || d.success !== true) throw new Error(d.message || 'Failed to jump to phase.');
      // wait for socket events to update UI
    } catch (err) {
      alert(err.message || 'Error jumping to phase.');
    }
  }

  function renderClusters(clusters) {
      elements.clusterVotingArea.innerHTML = ''; // Clear previous
      userVotes = {}; // Reset local tracking of user's votes for this phase

      if (!clusters || clusters.length === 0) {
          elements.clusterVotingArea.innerHTML = '<p class="text-muted">No clusters generated.</p>';
          return;
      }

      clusters.forEach(cluster => {
          const clusterDiv = document.createElement('div');
          clusterDiv.className = 'cluster-item card mb-3 shadow-sm';
          clusterDiv.id = `cluster-${cluster.id}`;
          clusterDiv.innerHTML = `
              <div class="card-body">
                  <h6 class="card-title d-flex justify-content-between align-items-center">
                      <span>${cluster.name || 'Unnamed Cluster'}</span>
                      <span class="badge bg-secondary rounded-pill vote-count" id="vote-count-${cluster.id}">0</span>
                  </h6>
                  ${cluster.description ? `<p class="card-text small text-muted">${cluster.description}</p>` : ''}
                  <button class="btn btn-sm btn-outline-primary vote-btn" data-cluster-id="${cluster.id}" ${workshopStatus === 'paused' ? 'disabled' : ''}>
                      <i class="bi bi-hand-thumbs-up"></i> Vote
                  </button>
                  {# Optional: Add a section to show ideas within the cluster #}
                  {# <div class="ideas-in-cluster small mt-2" style="max-height: 100px; overflow-y: auto;">...</div> #}
              </div>
          `;
          elements.clusterVotingArea.appendChild(clusterDiv);
      });

      // Add event listeners to NEW vote buttons
      elements.clusterVotingArea.querySelectorAll('.vote-btn').forEach(button => {
    // Default tooltip: only show the "remove" hint after user actually votes
    button.setAttribute('data-bs-toggle', 'tooltip');
    button.setAttribute('data-bs-placement', 'top');
    setTooltip(button, 'Vote for this cluster');
          button.addEventListener('click', handleVoteButtonClick);
      });
  }

  function renderGenericVoting(items) {
      const host = elements.genericVotingArea || document.getElementById('generic-vote-container');
      if (!host) return;
      // Ensure the container exists inside the host
      let root = host.querySelector('#generic-vote-container');
      if (!root) {
        root = document.createElement('div');
        root.id = 'generic-vote-container';
        host.innerHTML = '';
        host.appendChild(root);
      } else {
        root.innerHTML = '';
      }
      genericUserVotes = {};
      if (!items || items.length === 0) {
        root.innerHTML = '<p class="text-muted">No items available to vote on.</p>';
        return;
      }
      const frag = document.createDocumentFragment();
      items.forEach(it => {
        const type = (it && (it.type || 'manual'));
        const id = (it && (it.id != null ? it.id : ''));
        const key = `${type}:${id}`;
        const label = (it && (it.label || it.name || it.id || 'Item'));
        const desc = (it && it.description) ? `<div class="card-text small text-muted mt-1">${String(it.description).replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>` : '';
        const card = document.createElement('div');
        card.className = 'card mb-2 shadow-sm';
        card.innerHTML = `
          <div class="card-body py-2 d-flex align-items-center justify-content-between">
            <div class="me-2">
              <div class="fw-semibold">${String(label).replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>
              ${desc}
            </div>
            <div class="d-flex align-items-center gap-2">
              <span class="badge bg-secondary rounded-pill generic-vote-count" data-item-key="${key}">0</span>
              <button class="btn btn-sm btn-outline-primary generic-vote-btn" data-item-key="${key}" ${workshopStatus === 'paused' ? 'disabled' : ''}>
                <i class="bi bi-hand-thumbs-up"></i> Vote
              </button>
            </div>
          </div>`;
        frag.appendChild(card);
      });
      root.appendChild(frag);
      // Wire click handlers
      root.querySelectorAll('.generic-vote-btn').forEach(btn => {
        setTooltip(btn, 'Vote for this item');
        btn.addEventListener('click', handleGenericVoteButtonClick);
      });
  }

  function handleGenericVoteButtonClick(event) {
      const btn = event.currentTarget;
      if (!btn || btn.disabled) return;
      const key = btn.getAttribute('data-item-key');
      if (!key) return;
      btn.disabled = true; // temporarily
      socket.emit('submit_vote_generic', {
        room: roomName,
        workshop_id: workshopId,
        user_id: userId,
        item_key: key
      });
  }

  function updateGenericVoteDisplay(itemKey, totalVotes, voterUserId, voterDotsRemaining, actionTaken) {
      // Update badge count
      document.querySelectorAll(`.generic-vote-count[data-item-key="${itemKey}"]`).forEach(el => {
        el.textContent = String(totalVotes);
      });
      // If current user, update dots and toggle button state
      if (voterUserId === userId) {
        updateUserDots(voterDotsRemaining);
        const scope = elements.genericVotingArea || document;
        const btn = scope.querySelector(`#generic-vote-container .generic-vote-btn[data-item-key="${itemKey}"]`);
        if (btn) {
          btn.disabled = (workshopStatus === 'paused');
          if (actionTaken === 'voted') {
            genericUserVotes[itemKey] = true;
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-primary');
            btn.innerHTML = '<i class="bi bi-hand-thumbs-up-fill"></i> Voted';
            setTooltip(btn, 'Click again to remove your vote');
          } else if (actionTaken === 'unvoted') {
            delete genericUserVotes[itemKey];
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-outline-primary');
            btn.innerHTML = '<i class="bi bi-hand-thumbs-up"></i> Vote';
            setTooltip(btn, 'Vote for this item');
          } else if (actionTaken === 'none' || actionTaken === 'error') {
            // If no action taken (e.g., out of dots), just re-enable button
            // and leave state as-is
          }
        }
      }
  }

  function handleVoteButtonClick(event) {
      const button = event.currentTarget;
      const clusterId = button.dataset.clusterId;
      if (!clusterId || button.disabled) return;

      // Determine action based on whether user already voted for this locally
      // const action = userVotes[clusterId] ? 'decrement' : 'increment'; // Simple toggle logic

      // Prevent voting if no dots left (client-side check)
      // if (action === 'increment' && userDots <= 0) {
      //     alert("You have no dots left to vote.");
      //     return;
      // }

      console.log(`Emitting submit_vote for cluster ${clusterId}`);
      button.disabled = true; // Temporarily disable button

      socket.emit('submit_vote', {
          room: roomName,
          workshop_id: workshopId,
          user_id: userId,
          cluster_id: parseInt(clusterId),
          // action: action // Send intended action
      });

      // OPTIONAL: Optimistic UI update (update count locally immediately)
      // This can feel faster but might be briefly incorrect if server rejects vote.
      // const voteCountSpan = document.getElementById(`vote-count-${clusterId}`);
      // if (voteCountSpan) {
      //     let currentCount = parseInt(voteCountSpan.textContent) || 0;
      //     voteCountSpan.textContent = action === 'increment' ? currentCount + 1 : Math.max(0, currentCount - 1);
      // }
      // updateUserDots(action === 'increment' ? userDots - 1 : userDots + 1);
      // userVotes[clusterId] = (action === 'increment'); // Update local tracking
  }

  function updateUserDots(newDotCount) {
      userDots = Math.max(0, newDotCount); // Ensure non-negative
      if (elements.userDotsCount) {
          elements.userDotsCount.textContent = userDots;
      }
      // Maybe update voting instructions text too
      const instructionsElement = elements.taskBody.querySelector('p:last-of-type'); // Find instructions paragraph
      if (instructionsElement && currentTaskType === 'clustering_voting') {
           instructionsElement.textContent = `Use your dots to vote. You have ${userDots} dots remaining.`;
      }
  }

  function updateVoteDisplay(clusterId, totalVotes, voterUserId, voterDotsRemaining, actionTaken) {
      // Update the total vote count display for the cluster
      const voteCountSpan = document.getElementById(`vote-count-${clusterId}`);
      if (voteCountSpan) {
          voteCountSpan.textContent = totalVotes;
      }

      // If the update was triggered by the current user, update their dot count and button state
      if (voterUserId === userId) {
          updateUserDots(voterDotsRemaining);

          // Update local vote tracking and button appearance
          const button = elements.clusterVotingArea.querySelector(`.vote-btn[data-cluster-id="${clusterId}"]`);
          if (button) {
               button.disabled = (workshopStatus === 'paused'); // Re-enable button (unless paused)
               if (actionTaken === 'voted') {
                   userVotes[clusterId] = true;
                   button.classList.remove('btn-outline-primary');
                   button.classList.add('btn-primary'); // Make button look 'active'
                   button.innerHTML = '<i class="bi bi-hand-thumbs-up-fill"></i> Voted';
           setTooltip(button, 'Click again to remove your vote');
               } else if (actionTaken === 'unvoted') {
                   delete userVotes[clusterId];
                   button.classList.remove('btn-primary');
                   button.classList.add('btn-outline-primary'); // Make button look 'inactive'
                   button.innerHTML = '<i class="bi bi-hand-thumbs-up"></i> Vote';
           setTooltip(button, 'Vote for this cluster');
               }
          }
      }
  }



  function updateWorkshopStatusUI(newStatus) {
    console.log(`Updating UI for status: ${newStatus}`);
    workshopStatus = newStatus;
    const isPaused = workshopStatus === 'paused';
    const isInProgress = workshopStatus === 'inprogress';
    const isTaskActive = !!currentTaskId; // Check if a task is currently loaded

    // Update Status Badge
    elements.statusBadge.textContent = workshopStatus.charAt(0).toUpperCase() + workshopStatus.slice(1);
    elements.statusBadge.className = `badge ${isPaused ? 'bg-warning text-dark' : 'bg-success'}`;

    // Toggle Pause Overlay
    elements.pauseOverlay.classList.toggle('d-none', !isPaused);

    // Enable/Disable Chat Input
    elements.chatInput.disabled = isPaused;
    elements.chatForm.querySelector('button').disabled = isPaused;


  // Enable/Disable Task-Specific Inputs
  const ideaInputActive = currentTaskType === 'warm-up' || currentTaskType === 'brainstorming';
  const votingActive = currentTaskType === 'clustering_voting';

  // Enable/Disable Idea Input (only if idea task is active AND not paused)
  elements.ideaInput.disabled = isPaused || !(isTaskActive && ideaInputActive);
  elements.ideaSubmitBtn.disabled = isPaused || !(isTaskActive && ideaInputActive);
  // Ensure idea form container visibility reflects task activity & type
  elements.ideaFormContainer.style.display = (isTaskActive && ideaInputActive) ? 'block' : 'none';

    elements.clusterVotingArea.querySelectorAll('.vote-btn').forEach(btn => {
      btn.disabled = isPaused || !votingActive;
      // Update tooltip to explain why disabled when paused
      if (isPaused) setTooltip(btn, 'Voting is paused');
      else if (!userVotes[btn.dataset.clusterId]) setTooltip(btn, 'Vote for this cluster');
    });
    // Generic voting buttons (in Whiteboard area)
    const genericActive = currentTaskType === 'vote_generic';
    const genericScope = elements.genericVotingArea || document;
    genericScope.querySelectorAll('#generic-vote-container .generic-vote-btn').forEach(btn => {
      btn.disabled = isPaused || !genericActive;
      if (isPaused) setTooltip(btn, 'Voting is paused');
    });
    // Ensure voting area visibility matches task type (handled in displayTask)

    // Show/hide relevant organizer buttons
    if (isOrganizer) {
        if (elements.pauseWorkshopForm) elements.pauseWorkshopForm.style.display = isInProgress ? 'inline' : 'none';
        if (elements.resumeWorkshopForm) elements.resumeWorkshopForm.style.display = isPaused ? 'inline' : 'none';
        if (elements.stopWorkshopForm) elements.stopWorkshopForm.style.display = (isInProgress || isPaused) ? 'inline' : 'none';
  // Begin button: show only if status is inprogress AND no task is active yet
        if (elements.beginIntroForm) elements.beginIntroForm.style.display = (isInProgress && !isTaskActive) ? 'inline' : 'none';
  // Keep organizer controls visible; disable when no active task
  if (elements.nextTaskBtn) elements.nextTaskBtn.disabled = !isTaskActive;
  if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = !isTaskActive;
  if (elements.endTaskBtn) elements.endTaskBtn.disabled = !isTaskActive;
  // Keep Prev disabled when at first phase
  updatePrevNextDisabled();
    }

    // Handle timer interval on pause/resume
    if (isPaused && countdownInterval) {
        console.log("Clearing countdown interval due to pause.");
        clearInterval(countdownInterval);
        countdownInterval = null;
    try { if (window.FacilitatorTTS) window.FacilitatorTTS.cancelSpeech(); } catch(_) {}
    } else if (isInProgress && currentTaskId && !countdownInterval) {
      // If resuming, timer sync event should handle restarting the countdown
      console.log("Workshop resumed, waiting for timer_sync...");
    }
  }

  // --- Initialize Socket Connection ---
  const socket = io();
  try { 
    window._workshopSocket = socket; 
    // Expose primary socket globally so other modules (e.g., transcription.js) can reuse it
    // and attach listeners immediately, avoiding duplicate connections and missed events.
    window.socket = socket;
  } catch(_) {}

  async function hydrateWarmupState(options = {}) {
    if (!window.WarmupUI || typeof window.WarmupUI.hydrateFromCache !== 'function') {
      return null;
    }
    const opts = options || {};
    const allowRefresh = !!opts.refreshIfActive;
    const forceDisplay = !!opts.forceDisplay;
    const currentTypeNormalized = String(currentTaskType || '').replace('_', '-');
    const currentIdStr = (currentTaskId != null) ? String(currentTaskId) : null;
    return window.WarmupUI.hydrateFromCache({
      workshopId,
      applyPayload(payload) {
        if (!payload || typeof payload !== 'object') return;
        const typeKey = String(payload.task_type || '').replace('_', '-');
        if (typeKey !== 'warm-up') return;
        try { window.warmupOptions = Array.isArray(payload.options) ? payload.options : []; } catch (_) {}
        try { window.selectedWarmupIndex = typeof payload.selected_index === 'number' ? payload.selected_index : 0; } catch (_) {}
        const payloadTaskIdStr = (payload.task_id != null) ? String(payload.task_id) : null;
        const sameTask = !!(currentIdStr && payloadTaskIdStr && currentIdStr === payloadTaskIdStr);
        const shouldDisplay = forceDisplay || !currentTaskId || (allowRefresh && (currentTypeNormalized === 'warm-up' || sameTask));
        if (shouldDisplay) {
          displayTask(payload);
          try { window._lastTaskPayload = payload; } catch (_) {}
          const total = (typeof _getDuration === 'function') ? _getDuration(payload) : (payload.duration || payload.task_duration || 0);
          if (total) {
            const remaining = typeof payload.remaining_seconds === 'number' ? payload.remaining_seconds : total;
            startOrSyncCountdown(remaining, total);
          }
        }
        warmupHydrationApplied = true;
      }
    }).then((result) => {
      if (result && result.applied) {
        warmupHydrationApplied = true;
      }
      return result;
    }).catch((err) => {
      console.warn('[WarmUp] cache hydration failed', err);
      return null;
    });
  }

  // Immediately hydrate warm-up state on load so the active task survives page refreshes.
  hydrateWarmupState({ refreshIfActive: true });
  // Track current chat scope; initialize from sessionStorage if available
  (function initChatScopeFromSession(){
    try {
      const key = `ws:${workshopId}:chatFilter`;
      const saved = sessionStorage.getItem(key);
      if (saved === 'discussion_chat' || saved === 'workshop_chat') {
        window.currentChatScope = saved;
      } else {
        window.currentChatScope = 'workshop_chat';
      }
    } catch(_) { window.currentChatScope = 'workshop_chat'; }
  })();

  // ADD: central chat scope switcher to avoid re-joining loops
  function switchChatScope(nextScope) {
    const normalized = (nextScope === 'discussion_chat') ? 'discussion_chat' : 'workshop_chat';
    if (window.currentChatScope === normalized) return false; // no-op if unchanged
    window.currentChatScope = normalized;
    if (elements.chatScope) elements.chatScope.value = normalized;
    // Persist selection for this workshop in this tab session
    try { sessionStorage.setItem(`ws:${workshopId}:chatFilter`, normalized); } catch(_) {}
    // Do NOT re-emit join_room on scope change; this triggers server to re-send full state repeatedly.
    // Instead, fetch history for the selected scope and filter live messages client-side.
    try { requestAndRenderChatHistory(normalized); } catch(_) {}
    return true;
  }

  // Respect saved chat filter; only apply default if unset for this session
  function setChatScopeDefaultIfUnset(defaultScope) {
    try {
      const key = `ws:${workshopId}:chatFilter`;
      const saved = sessionStorage.getItem(key);
      if (saved === 'discussion_chat' || saved === 'workshop_chat') {
        // Ensure UI reflects saved preference and history is loaded
        window.currentChatScope = saved;
        if (elements.chatScope) elements.chatScope.value = saved;
        try { requestAndRenderChatHistory(saved); } catch(_) {}
        return false;
      }
      const normalized = (defaultScope === 'discussion_chat') ? 'discussion_chat' : 'workshop_chat';
      // Set only once if nothing saved yet
      window.currentChatScope = normalized;
      if (elements.chatScope) elements.chatScope.value = normalized;
      try { sessionStorage.setItem(key, normalized); } catch(_) {}
      try { requestAndRenderChatHistory(normalized); } catch(_) {}
      return true;
    } catch(_) { return false; }
  }

  socket.on('connect', () => {
    console.log(`Socket connected (SID: ${socket.id}), joining room: ${roomName}`);
    socket.emit('join_room', {
      room: roomName,
      workshop_id: workshopId,
      user_id: userId,
      scope: (window.currentChatScope || 'workshop_chat')
    });
    const normalizedType = String(currentTaskType || '').replace('_', '-');
    if (!warmupHydrationApplied || normalizedType === 'warm-up') {
      hydrateWarmupState({ refreshIfActive: true });
    }
  });

  socket.on('connect_error', (err) => { /* (Keep as is) */ });
  socket.on('disconnect', (reason) => { /* (Keep as is) */ });


  // --- Socket Event Handlers ---

  socket.on('workshop_status_update', (data) => {
      if (data.workshop_id !== workshopId) return;
      console.log("Received status update:", data.status);
      updateWorkshopStatusUI(data.status);
  });

  // (Duplicate socket initialization and handlers removed)

  // React to pause/resume in place (no full reload) to keep UX snappy
  socket.on('workshop_paused', (d) => {
    if (!d || d.workshop_id !== workshopId) return;
    console.log('Workshop paused event received. Updating UI...');
    updateWorkshopStatusUI('paused');
  });
  socket.on('workshop_resumed', (d) => {
    if (!d || d.workshop_id !== workshopId) return;
    console.log('Workshop resumed event received. Updating UI...');
    updateWorkshopStatusUI('inprogress');
  });

  socket.on('workshop_stopped', d => {
    if (!d || d.workshop_id !== workshopId) return;
    console.log('Workshop stopped/completed. Redirecting to report...');
    // Disable actions and redirect to report
    document.querySelectorAll('form button[type="submit"]').forEach(btn => btn.disabled = true);
    window.location.href = `/workshop/report/${workshopId}`;
  });

  // Task start events
  function handleWarmUpStart(data) {
    if (!data || !data.task_id) {
      console.error('Received warm-up start without task_id:', data);
      return;
    }
    console.log('[WarmUp] start payload:', data);
    const banner = document.getElementById('warmup-confirm-banner');
    if (banner) {
      banner.classList.add('d-none');
      banner.classList.remove('show');
      const summaryEl = document.getElementById('warmup-confirm-summary');
      const handoffEl = document.getElementById('warmup-handoff-phrase');
      const nextEl = document.getElementById('warmup-next-phase-hint');
      if (summaryEl) summaryEl.textContent = '';
      if (handoffEl) {
        handoffEl.textContent = '';
        handoffEl.classList.add('d-none');
      }
      if (nextEl) {
        nextEl.textContent = '';
        nextEl.classList.add('d-none');
      }
    }
    displayTask(data);
    try { window._lastTaskPayload = data; } catch(_) {}
    const originalDuration = _getDuration(data);
    const remaining = (typeof data.remaining_seconds === 'number') ? data.remaining_seconds : originalDuration;
    startOrSyncCountdown(remaining, originalDuration);

    if (isOrganizer && elements.beginIntroForm && elements.nextTaskBtn) {
      elements.beginIntroForm.classList.add('d-none');
      elements.nextTaskBtn.innerHTML = 'Next Task';
      elements.nextTaskBtn.disabled = true;
      if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = false;
      if (elements.endTaskBtn) elements.endTaskBtn.disabled = false;
      if (typeof updatePrevNextDisabled === 'function') updatePrevNextDisabled();
      const area = document.getElementById('notification-area');
      if (area) {
        const div = document.createElement('div');
        div.className = 'alert alert-success alert-dismissible fade show shadow-sm';
        div.role = 'alert';
        div.innerHTML = `Workshop started. Organizer controls ready.
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
        area.appendChild(div);
        setTimeout(() => {
          try { const inst = bootstrap.Alert.getOrCreateInstance(div); inst.close(); } catch { /* no-op */ }
        }, 3000);
      }
    }

  }

  socket.on('warm_up_start', handleWarmUpStart);

  socket.on('warm_up_option_changed', (data) => {
    if (!data || !data.task_id) {
      console.warn('Received warm_up_option_changed without task context:', data);
      return;
    }
    if (data.workshop_id && Number(data.workshop_id) !== Number(workshopId)) {
      return;
    }
    console.log('[WarmUp] option changed:', data);
    try {
      if (window.__warmupModalInstance && typeof window.__warmupModalInstance.hide === 'function') {
        window.__warmupModalInstance.hide();
      }
    } catch (_) {
      /* no-op */
    }
    displayTask(data);
    try { window._lastTaskPayload = data; } catch(_) {}
    if (Array.isArray(data.options)) {
      window.warmupOptions = data.options;
    }
    if (typeof data.selected_index === 'number') {
      window.selectedWarmupIndex = data.selected_index;
    }
    const originalDuration = _getDuration(data);
    if (originalDuration) {
      const remaining = (typeof data.remaining_seconds === 'number') ? data.remaining_seconds : originalDuration;
      startOrSyncCountdown(remaining, originalDuration);
    }
  });

  socket.on('warm_up_completed', (data) => {
    console.log('[WarmUp] completed:', data);
    try { window._lastWarmUpCompletion = data; } catch (_) { /* no-op */ }
    try {
      if (window.WarmupUI && typeof window.WarmupUI.dismissModal === 'function') {
        window.WarmupUI.dismissModal();
      }
    } catch (_) { /* no-op */ }
    if (data && Array.isArray(data.options)) {
      window.warmupOptions = data.options;
    } else {
      window.warmupOptions = [];
    }
    if (data && typeof data.selected_index === 'number') {
      window.selectedWarmupIndex = data.selected_index;
    } else {
      window.selectedWarmupIndex = null;
    }
    const banner = document.getElementById('warmup-confirm-banner');
    if (banner && isOrganizer) {
      const options = Array.isArray(data?.options) ? data.options : Array.isArray(window.warmupOptions) ? window.warmupOptions : [];
      const selectedIdxRaw = typeof data?.selected_index === 'number' ? data.selected_index : window.selectedWarmupIndex;
      const selectedIdx = (typeof selectedIdxRaw === 'number' && selectedIdxRaw >= 0) ? selectedIdxRaw : null;
      const selectedOpt = (selectedIdx !== null && options[selectedIdx]) ? options[selectedIdx] : null;
      const summaryEl = document.getElementById('warmup-confirm-summary');
      const handoffEl = document.getElementById('warmup-handoff-phrase');
      const nextEl = document.getElementById('warmup-next-phase-hint');
      if (summaryEl) {
        const parts = [];
        if (selectedOpt && typeof selectedOpt.title === 'string' && selectedOpt.title.trim()) {
          parts.push(selectedOpt.title.trim());
        }
        if (selectedOpt && typeof selectedOpt.mode === 'string' && selectedOpt.mode.trim()) {
          const modeLabel = selectedOpt.mode.replace(/_/g, ' ');
          parts.push(modeLabel.charAt(0).toUpperCase() + modeLabel.slice(1));
        }
        if (selectedOpt && typeof selectedOpt.timer_sec === 'number') {
          parts.push(`${selectedOpt.timer_sec}s`);
        }
        summaryEl.textContent = parts.length ? parts.join(' • ') : 'Warm-up selection confirmed.';
      }
      if (handoffEl) {
        const handoff = (typeof data?.handoff_phrase === 'string') ? data.handoff_phrase.trim() : '';
        if (handoff) {
          handoffEl.textContent = handoff;
          handoffEl.classList.remove('d-none');
        } else {
          handoffEl.textContent = '';
          handoffEl.classList.add('d-none');
        }
      }
      if (nextEl) {
        let nextCopy = '';
        const nextPhase = (data && typeof data.next_phase === 'object' && data.next_phase !== null) ? data.next_phase : null;
        if (nextPhase) {
          const label = typeof nextPhase.next_phase === 'string' && nextPhase.next_phase.trim() ? nextPhase.next_phase.trim() : null;
          const taskType = typeof nextPhase.next_task_type === 'string' && nextPhase.next_task_type.trim() ? nextPhase.next_task_type.trim() : null;
          const eta = typeof nextPhase.starts_in_seconds === 'number' ? nextPhase.starts_in_seconds : null;
          if (label) {
            nextCopy = label;
          } else if (taskType) {
            nextCopy = taskType.replace(/_/g, ' ');
          }
          if (eta && eta > 0) {
            const mins = Math.round(eta / 60);
            if (mins > 0) {
              nextCopy = nextCopy ? `${nextCopy} in ~${mins} min` : `Next step in ~${mins} min`;
            }
          }
        }
        if (nextCopy) {
          nextEl.textContent = `Next: ${nextCopy}`;
          nextEl.classList.remove('d-none');
        } else {
          nextEl.textContent = '';
          nextEl.classList.add('d-none');
        }
      }
      banner.classList.remove('d-none');
      banner.classList.add('show');
      try {
        bootstrap.Alert.getOrCreateInstance(banner);
      } catch (_) { /* no-op */ }
    }
    const area = document.getElementById('notification-area');
    if (area) {
      const alert = document.createElement('div');
      alert.className = 'alert alert-info alert-dismissible fade show shadow-sm';
      alert.setAttribute('role', 'alert');

      const heading = document.createElement('div');
      heading.className = 'fw-semibold mb-1';
      heading.textContent = 'Warm-Up Complete';
      alert.appendChild(heading);

      if (data && typeof data.handoff_phrase === 'string' && data.handoff_phrase.trim().length > 0) {
        const phrase = document.createElement('div');
        phrase.textContent = data.handoff_phrase;
        alert.appendChild(phrase);
      }

      if (data && typeof data.next_phase === 'object' && data.next_phase !== null) {
        const nextName = data.next_phase.next_phase || data.next_phase.next_task_type;
        if (typeof nextName === 'string' && nextName.trim().length > 0) {
          const phase = document.createElement('div');
          phase.className = 'mt-2 small text-muted';
          phase.textContent = `Next: ${nextName}`;
          alert.appendChild(phase);
        }
      }

      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.className = 'btn-close';
      closeBtn.setAttribute('data-bs-dismiss', 'alert');
      closeBtn.setAttribute('aria-label', 'Close');
      alert.appendChild(closeBtn);

      area.appendChild(alert);
      setTimeout(() => {
        try { bootstrap.Alert.getOrCreateInstance(alert).close(); } catch (_) { /* no-op */ }
      }, 6000);
    }
  });

  socket.on('task_ready', payload => {
    console.log('[Socket] task_ready', payload);
  displayTask(payload);
  try { window._lastTaskPayload = payload; } catch(_) {}

    const dur = _getDuration(payload);
    startOrSyncCountdown(dur, dur);

    // Stop spinner but keep disabled until task ends
    if (elements.nextTaskBtn) {
      elements.nextTaskBtn.innerHTML = 'Next Task';
      elements.nextTaskBtn.disabled = true;
    }
    if (isOrganizer) {
      if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = false;
      if (elements.endTaskBtn) elements.endTaskBtn.disabled = false;
  if (typeof updatePrevNextDisabled === 'function') updatePrevNextDisabled();
    }
});

['clusters_ready','discussion_ready','feasibility_ready','summary_ready','prioritization_ready','action_plan_ready']
  .forEach(evt =>
    socket.on(evt, payload => {
      console.log(`[Socket] ${evt}`, payload);
  displayTask(payload);
  try { window._lastTaskPayload = payload; } catch(_) {}
      const d = _getDuration(payload);
      startOrSyncCountdown(d, d);
      if (elements.nextTaskBtn) {
        elements.nextTaskBtn.innerHTML = 'Next Task';
        elements.nextTaskBtn.disabled = true;
      }
      if (isOrganizer) {
        if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = false;
        if (elements.endTaskBtn) elements.endTaskBtn.disabled = false;
  if (typeof updatePrevNextDisabled === 'function') updatePrevNextDisabled();
      }
    })
  );

  // New task types: meeting, presentation, speech, vote (generic)
  ['meeting_ready','presentation_ready','speech_ready','framing_ready','vote_ready']
    .forEach(evt =>
      socket.on(evt, payload => {
        console.log(`[Socket] ${evt}`, payload);
        // If video conferencing is enabled, auto-start on first actionable phase
        ensureConferenceAutoStartIfEnabled();
        displayTask(payload);
        try { window._lastTaskPayload = payload; } catch(_) {}
        const dur = _getDuration(payload);
        startOrSyncCountdown(dur, dur);
        if (elements.nextTaskBtn) {
          elements.nextTaskBtn.innerHTML = 'Next Task';
          elements.nextTaskBtn.disabled = true;
        }
        if (isOrganizer) {
          if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = false;
          if (elements.endTaskBtn) elements.endTaskBtn.disabled = false;
          if (typeof updatePrevNextDisabled === 'function') updatePrevNextDisabled();
        }
      })
    );

  //socket.on('clusters_ready', (data) => displayTask(data));
  //socket.on('feasibility_ready', (data) => displayTask(data));
  //socket.on('summary_ready', (data) => displayTask(data));
  //socket.on('discussion_ready', (data) => displayTask(data));

  socket.on('timer_sync', (data) => {
    if (!data || typeof data !== 'object') {
      console.warn('Received malformed timer_sync payload:', data);
      return;
    }
    // If server indicates paused state, sync the UI immediately (defensive against missing status events)
    try {
      if (typeof data.is_paused === 'boolean') {
        updateWorkshopStatusUI(data.is_paused ? 'paused' : 'inprogress');
      }
    } catch(_) {}
    // Bootstrap on first tick if race condition: timer_sync arrives before task render
    if (!currentTaskId && data.task_id) {
      console.warn('[Bootstrap] timer_sync arrived before task payload. Bootstrapping currentTaskId from timer_sync.');
      try { currentTaskId = data.task_id; } catch (_) {}
      // If we don't yet know the total duration, best-effort estimate from payloads
      if (!totalDurationForCurrentTask || totalDurationForCurrentTask <= 0) {
        let guessedTotal = 0;
        try {
          if (typeof _getDuration === 'function' && window._lastTaskPayload) {
            guessedTotal = _getDuration(window._lastTaskPayload) || 0;
          }
        } catch (_) {}
        if (!guessedTotal) {
          // Fallback to total_seconds if provided by server, else use remaining_seconds
          guessedTotal = (data.total_seconds || data.remaining_seconds || 0);
        }
        try { totalDurationForCurrentTask = guessedTotal; } catch (_) {}
      }
    }

    if (data.task_id === currentTaskId) {
      console.log('Received timer_sync:', data);
      // Use totalDurationForCurrentTask stored locally when task started/displayed (or bootstrapped above)
      const rawTotal = (totalDurationForCurrentTask && totalDurationForCurrentTask > 0)
        ? totalDurationForCurrentTask
        : (data.total_seconds ?? data.totalSeconds ?? data.remaining_seconds ?? data.remainingSeconds ?? 0);
      const rawRemaining = data.remaining_seconds ?? data.remainingSeconds ?? null;
      const parsedRemaining = typeof rawRemaining === 'number' ? rawRemaining : parseInt(rawRemaining, 10);
      if (!Number.isFinite(parsedRemaining)) {
        console.warn('timer_sync missing remaining_seconds value. Skipping update.', data);
        return;
      }
      startOrSyncCountdown(parsedRemaining, rawTotal);
    } else {
      console.log('Ignoring timer_sync for different/old task:', data.task_id, 'current:', currentTaskId);
    }
  });

  socket.on('whiteboard_sync', (data) => {
      console.log("Received whiteboard_sync:", data);
      if (!elements.stickyBoard) return;
      const ideas = Array.isArray(data.ideas) ? data.ideas : [];
      const shouldShowPlaceholder = !ideas.length && (currentTaskType === 'warm-up' || currentTaskType === 'brainstorming');
      rebuildWhiteboardPlaceholder(shouldShowPlaceholder);
      if (ideas.length) {
        hydrateWhiteboardFromIdeas(ideas, { tempPrefix: `sync-${currentTaskId || 'task'}` });
      }
      if (typeof data.ai_ideas_include_in_outputs !== 'undefined') {
        setAiIdeaIncludeState(!!data.ai_ideas_include_in_outputs, { preserveIdeaFlags: true });
      } else {
        // Re-apply current state to ensure newly rendered notes have correct appearance
        setAiIdeaIncludeState(aiIdeaIncludeState, { preserveIdeaFlags: true, skipSwitch: true });
      }
  });

  socket.on('new_idea', data => {
    if (data.task_id === currentTaskId) {
        console.log('New idea received:', data);
        addStickyNote(data);
    } else {
        console.log("Ignoring new_idea for different task:", data.task_id, "current:", currentTaskId);
    }
  });

  socket.on('ai_idea_inclusion', (data) => {
    try {
      if (!data || data.workshop_id !== workshopId) return;
      const include = data.include !== false;
      document.querySelectorAll('.sticky-note[data-source="ai"]').forEach(note => {
        note.dataset.includeInOutputs = include ? 'true' : 'false';
      });
      setAiIdeaIncludeState(include);
    } catch (err) {
      console.warn('Failed to apply ai_idea_inclusion update', err);
    }
  });

  const discussionEventHandlers = {
    discussion_payload_updated: (payload) => {
      if (!payload || !payload.payload) return;
      applyDiscussionPayload(payload.payload);
      setDiscussionRunStatus('Discussion updated', 'info');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    discussion_notes_updated: (payload) => {
      if (!payload || !Array.isArray(payload.notes)) return;
      applyDiscussionOutputs({ discussion_notes: payload.notes });
      setDiscussionRunStatus('Notes refreshed', 'info');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    discussion_notes_added: (payload) => {
      if (!payload || !Array.isArray(payload.notes)) return;
      applyDiscussionOutputs({ discussion_notes: payload.notes });
      setDiscussionRunStatus('Notes refreshed', 'info');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    discussion_decisions_updated: (payload) => {
      if (!payload || !Array.isArray(payload.decisions)) return;
      applyDiscussionOutputs({ decisions: payload.decisions });
      setDiscussionRunStatus('Decisions updated', 'info');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    decisions_updated: (payload) => {
      if (!payload || !Array.isArray(payload.decisions)) return;
      applyDiscussionOutputs({ decisions: payload.decisions });
      setDiscussionRunStatus('Decisions updated', 'info');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    devil_advocate_ready: (payload) => {
      if (!payload || !Array.isArray(payload.items)) return;
      applyDiscussionOutputs({ devil_advocate: payload.items });
      setDiscussionRunStatus("Devil's advocate is ready", 'warning');
      if (typeof displayNotification === 'function') displayNotification("Devil's advocate prompts are ready.");
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    discussion_devil_advocate: (payload) => {
      if (!payload || !Array.isArray(payload.items)) return;
      applyDiscussionOutputs({ devil_advocate: payload.items });
      setDiscussionRunStatus("Devil's advocate is ready", 'warning');
      if (typeof displayNotification === 'function') displayNotification("Devil's advocate prompts are ready.");
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    mediator_prompt_ready: (payload) => {
      if (!payload || !payload.prompt) return;
      applyDiscussionOutputs({ mediator_prompt: payload.prompt });
      setDiscussionRunStatus('Mediator prompt ready', 'success');
      if (typeof displayNotification === 'function') displayNotification('Mediator prompt ready for review.');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    discussion_mediator_prompt: (payload) => {
      if (!payload || !payload.prompt) return;
      applyDiscussionOutputs({ mediator_prompt: payload.prompt });
      setDiscussionRunStatus('Mediator prompt ready', 'success');
      if (typeof displayNotification === 'function') displayNotification('Mediator prompt ready for review.');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    scribe_summary_ready: (payload) => {
      if (!payload || !payload.summary) return;
      applyDiscussionOutputs({ scribe_summary: payload.summary });
      setDiscussionRunStatus('Scribe summary captured', 'success');
      if (typeof displayNotification === 'function') displayNotification('Scribe summary posted to the discussion panel.');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    discussion_scribe_summary: (payload) => {
      if (!payload || !payload.summary) return;
      applyDiscussionOutputs({ scribe_summary: payload.summary });
      setDiscussionRunStatus('Scribe summary captured', 'success');
      if (typeof displayNotification === 'function') displayNotification('Scribe summary posted to the discussion panel.');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
    forum_seed_done: (payload) => {
      if (!payload || payload.success !== true) return;
      setDiscussionRunStatus('Forum seeded', 'success');
      if (typeof displayNotification === 'function') displayNotification('Forum was seeded with the latest discussion context.');
      setTimeout(() => setDiscussionRunStatus('', 'light'), 3500);
    },
  };

  Object.entries(discussionEventHandlers).forEach(([eventName, handler]) => {
    socket.on(eventName, (payload) => {
      if (currentTaskType !== 'discussion') return;
      try {
        handler(payload || {});
      } catch (err) {
        console.error(`Failed handling ${eventName}`, err);
      }
    });
  });

  // Chat history synchronization
  socket.on('chat_history', (data) => {
      console.log("Received chat_history:", data);
      if (!elements.chatMessages) return;
      elements.chatMessages.innerHTML = ''; // Clear existing messages
      if (data.messages && data.messages.length > 0) {
    data.messages.forEach(msg => appendChatMessage(msg.user_name, msg.message, msg.timestamp, true, msg.message_type || 'user'));
          // Scroll to bottom after loading history
          elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      }
  });

  // New chat message event
  socket.on('receive_message', d => {
    if (!d) return;
    const msgScope = d.chat_scope || 'workshop_chat';
    const currentScope = (window.currentChatScope || 'workshop_chat');
    if (msgScope !== currentScope) return; // ignore messages for other scopes
    appendChatMessage(d.user_name, d.message, d.timestamp, false, d.message_type || 'user');
  });

  // Participant list update event
  socket.on('participant_list_update', data => { 
    if (data && data.workshop_id === workshopId) {
      updateParticipantsList(data.participants || []);
    }
  });

  // UI hint propagation (organizer toggles visible UI flags without server roundtrip)
  socket.on('ui_hint', msg => {
    try {
      if (!msg || msg.workshop_id !== workshopId) return;
      if (msg.key === 'showRationaleAll') {
        try { sessionStorage.setItem(`ws:${workshopId}:showRationaleAll`, JSON.stringify(!!msg.value)); } catch(_) {}
        // When turning on, if rationale exists but wasn't mounted (participant view), re-render minimal block
        if (!!msg.value && window._lastTaskPayload && window._lastTaskPayload.task_type === 'results_prioritization') {
          // Avoid duplicating if already present
          if (!document.querySelector('.shortlist-rationale-block')) {
            displayTask(Object.assign({}, window._lastTaskPayload));
          }
        } else if (!msg.value) {
          // Hide rationale block for participants
          document.querySelectorAll('.shortlist-rationale-block').forEach(el => el.remove());
        }
      }
    } catch(_) {}
  });

  // --- ADDED: Vote Update Handler ---
  socket.on('vote_update', (data) => {
      console.log("Received vote_update:", data);
      if (data.cluster_id) {
          updateVoteDisplay(data.cluster_id, data.total_votes, data.user_id, data.dots_remaining, data.action_taken);
      }
  });

  // --- ADDED: Generic voting handlers ---
  socket.on('generic_votes_sync', (data) => {
    // data.counts is a map of itemKey -> count
    try {
      const counts = (data && data.counts) || {};
      for (const key in counts) {
        document.querySelectorAll(`.generic-vote-count[data-item-key="${key}"]`).forEach(el => {
          el.textContent = String(counts[key]);
        });
      }
    } catch (_) {}
  });

  socket.on('generic_user_votes_sync', (data) => {
    // data.items is an array of itemKeys user voted for
    try {
      const items = (data && Array.isArray(data.items)) ? data.items : [];
      items.forEach(key => {
        genericUserVotes[key] = true;
        const scope = elements.genericVotingArea || document;
        const btn = scope.querySelector(`#generic-vote-container .generic-vote-btn[data-item-key="${key}"]`);
        if (btn) {
          btn.classList.remove('btn-outline-primary');
          btn.classList.add('btn-primary');
          btn.innerHTML = '<i class="bi bi-hand-thumbs-up-fill"></i> Voted';
          setTooltip(btn, 'Click again to remove your vote');
        }
      });
    } catch (_) {}
  });

  socket.on('generic_vote_update', (data) => {
    try {
      if (!data || !data.item_key) return;
      updateGenericVoteDisplay(data.item_key, data.total_votes || 0, data.user_id, data.dots_remaining || 0, data.action_taken || 'none');
    } catch (_) {}
  });

  // Task completed (from server auto-complete or organizer action)
  socket.on('task_completed', (data) => {
    if (!data || data.workshop_id !== workshopId) return;
    console.log('Received task_completed:', data);
    handleTimerEnd();
    // Show a small toast to clarify server auto-end
    const area = document.getElementById('notification-area');
    if (area) {
      const div = document.createElement('div');
      div.className = 'alert alert-info alert-dismissible fade show shadow-sm';
      div.role = 'alert';
      div.innerHTML = `Time is up for this phase. ${isOrganizer ? 'Advancing shortly…' : ''}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
      area.appendChild(div);
      setTimeout(() => {
        const inst = bootstrap.Alert.getOrCreateInstance(div); inst.close();
      }, 8000);
    }
  });

   // --- ADDED: Sync All Votes Handler (for joins) ---
   socket.on('all_votes_sync', (data) => {
       console.log("Received all_votes_sync:", data);
       if (data.votes && currentTaskType === 'clustering_voting') {
           for (const clusterId in data.votes) {
               const voteCountSpan = document.getElementById(`vote-count-${clusterId}`);
               if (voteCountSpan) {
                   voteCountSpan.textContent = data.votes[clusterId];
               }
           }
           // Also need to update button states based on user's previous votes if possible
           // This requires fetching the user's votes for this task on join
           // Or modifying the 'clusters_ready' payload to include user's vote status per cluster
       }
   });

   // New: Sync the current user's existing votes to toggle button UI on load
   socket.on('user_votes_sync', (data) => {
     console.log('Received user_votes_sync:', data);
     if (!data || !Array.isArray(data.voted_cluster_ids)) return;
     data.voted_cluster_ids.forEach((cid) => {
       try {
         userVotes[String(cid)] = true;
         const button = elements.clusterVotingArea.querySelector(`.vote-btn[data-cluster-id="${cid}"]`);
         if (button) {
           button.classList.remove('btn-outline-primary');
           button.classList.add('btn-primary');
           button.innerHTML = '<i class="bi bi-hand-thumbs-up-fill"></i> Voted';
           setTooltip(button, 'Click again to remove your vote');
         }
       } catch (_) {}
     });
   });


  // --- ADDED: Handle No Active Task ---
  socket.on('no_active_task', () => {
       console.log("Received no_active_task signal.");
       currentTaskId = null;
       currentTaskType = null;
  show(elements.taskPlaceholder);
  hide(elements.taskContent);
  hide(elements.stickyBoard);
  hide(elements.clusterVotingArea);
  hide(elements.genericVotingArea);
  hide(elements.reportArea);
  hide(elements.ideaFormContainer);
  hide(elements.userDotsDisplay);
  try { if (window.FacilitatorTTS) window.FacilitatorTTS.cancelSpeech(); } catch(_) {}
  resetTimerVisuals();
  if (isOrganizer && elements.beginIntroForm && workshopStatus === 'inprogress') {
       elements.beginIntroForm.classList.remove('d-none');
     }
  if (elements.nextTaskBtn) elements.nextTaskBtn.disabled = true;
  if (elements.prevTaskBtn) elements.prevTaskBtn.disabled = true;
  if (elements.endTaskBtn) elements.endTaskBtn.disabled = true;
  resetPhaseUI();
   });

      // --- ADDED: Moderator Nudge Handler ---
      socket.on('moderator_nudge', (data) => {
       // Check if the nudge is for the current user
       if (data.target_user_id === userId) {
           console.log("[Moderator] Received nudge:", data.message);
           displayNotification(data.message);
       }
   });

   function displayNotification(message) {
       const notificationArea = document.getElementById('notification-area');
       if (!notificationArea) return;

       const notificationId = `notif-${Date.now()}`;
       const notificationDiv = document.createElement('div');
       notificationDiv.id = notificationId;
       notificationDiv.className = 'alert alert-info alert-dismissible fade show shadow-sm'; // Use Bootstrap alert classes
       notificationDiv.setAttribute('role', 'alert');
       notificationDiv.innerHTML = `
           ${message}
           <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
       `;

       notificationArea.appendChild(notificationDiv);

       // Automatically remove the notification after 10 seconds
       setTimeout(() => {
           const element = document.getElementById(notificationId);
           if (element) bootstrap.Alert.getOrCreateInstance(element).close(); // Use Bootstrap's JS to close
       }, 10000); // 10 seconds
   }




  // --- Event Listeners (DOM Ready) ---
  document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.discussion-action-btn').forEach((btn) => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          const requireConfirm = action === 'forum-seed';
          if (requireConfirm && !confirm('Seed forum from clusters and ideas? This is idempotent.')) {
            return;
          }
          performDiscussionAction(action, { button: btn });
        });
      });
      // Forum seed button (organizer only)
      const seedBtn = document.getElementById('forum-seed-btn');
      if (seedBtn) {
        seedBtn.addEventListener('click', () => {
          if (!confirm('Seed forum from clusters and ideas? This is idempotent.')) return;
          performDiscussionAction('forum-seed', { button: seedBtn });
        });
      }
      if (isOrganizer && elements.aiIdeaIncludeSwitch) {
        const toggleEl = elements.aiIdeaIncludeSwitch;
        toggleEl.checked = aiIdeaIncludeState;
        toggleEl.addEventListener('change', async (event) => {
          if (aiIdeaToggleInFlight) {
            event.preventDefault();
            toggleEl.checked = aiIdeaIncludeState;
            return;
          }
          const include = !!toggleEl.checked;
          const previous = aiIdeaIncludeState;
          aiIdeaToggleInFlight = true;
          toggleEl.disabled = true;
          try {
            setAiIdeaIncludeState(include, { skipSwitch: true });
            const response = await fetch(`/workshop/${workshopId}/ai_ideas_toggle`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
              },
              body: JSON.stringify({ include })
            });
            const payload = await response.json().catch(() => ({}));
            if (!response.ok || (payload && payload.success === false)) {
              throw new Error(payload && payload.message ? payload.message : 'Request failed');
            }
            const includeResp = (payload && typeof payload.include === 'boolean') ? payload.include : include;
            setAiIdeaIncludeState(includeResp, { skipSwitch: true });
            toggleEl.checked = includeResp;
          } catch (err) {
            console.error('Failed updating AI idea inclusion', err);
            alert(err && err.message ? err.message : 'Unable to update AI idea inclusion.');
            toggleEl.checked = previous;
            setAiIdeaIncludeState(previous, { skipSwitch: true });
          } finally {
            aiIdeaToggleInFlight = false;
            toggleEl.disabled = false;
          }
        });
      } else if (!isOrganizer) {
        setAiIdeaIncludeState(aiIdeaIncludeState, { skipSwitch: true, preserveIdeaFlags: true });
      }
      // Initialize organizer auto-advance controls
      if (isOrganizer) {
        const sw = document.getElementById('auto-advance-switch');
        const sec = document.getElementById('auto-advance-seconds');
        if (sw && sec) {
          sw.checked = !!autoAdvanceEnabled;
          sec.value = String(autoAdvanceDelaySeconds || 0);
          const debouncedUpdate = (() => {
            let t; return (payload) => { clearTimeout(t); t = setTimeout(() => doUpdate(payload), 250); };
          })();
          const doUpdate = (payload) => {
            fetch(`/workshop/${workshopId}/settings/auto_advance`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
              body: JSON.stringify(payload)
            }).then(r => r.json().catch(() => ({}))).then(d => {
              if (d && d.success) {
                // local state will be updated via socket broadcast
              } else {
                throw new Error(d.message || 'Failed to update auto-advance');
              }
            }).catch(err => {
              console.error('Auto-advance update error:', err);
              // Revert UI on error
              sw.checked = autoAdvanceEnabled;
              sec.value = String(autoAdvanceDelaySeconds || 0);
            });
          };
          sw.addEventListener('change', () => {
            const enabled = sw.checked;
            const secs = Math.max(0, parseInt(sec.value || '0', 10) || 0);
            debouncedUpdate({ enabled, after_seconds: secs });
          });
          sec.addEventListener('change', () => {
            const enabled = sw.checked;
            const secs = Math.max(0, parseInt(sec.value || '0', 10) || 0);
            debouncedUpdate({ enabled, after_seconds: secs });
          });
        }
      }

      // Attach handlers for organizer forms (Pause, Resume, Stop)
      [elements.pauseWorkshopForm, elements.resumeWorkshopForm, elements.stopWorkshopForm].forEach(form => {
          if (form) form.addEventListener('submit', e => postForm(e, form));
      });

      // Organizer navigation: Prev / End / Next
      if (isOrganizer) {
        if (elements.prevTaskBtn) {
          elements.prevTaskBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            const btn = elements.prevTaskBtn;
            const original = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Prev…';
            try {
              const r = await fetch(`/workshop/${workshopId}/nav/prev`, { method: 'POST', headers: { 'X-Requested-With': 'XMLHttpRequest' }});
              const d = await r.json().catch(() => ({}));
              if (!r.ok || d.success !== true) throw new Error(d.message || 'Failed to go to previous task.');
              // Wait for sockets to sync UI (task_ready)
            } catch (err) {
              alert(err.message || 'Error going to previous task.');
            } finally {
              btn.disabled = false;
              btn.innerHTML = original;
            }
          });
        }
        if (elements.endTaskBtn) {
          elements.endTaskBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            if (!confirm('End the current phase now?')) return;
            const btn = elements.endTaskBtn;
            const original = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Ending…';
            try {
              const r = await fetch(`/workshop/${workshopId}/end_current`, { method: 'POST', headers: { 'X-Requested-With': 'XMLHttpRequest' }});
              const d = await r.json().catch(() => ({}));
              if (!r.ok || d.success !== true) throw new Error(d.message || 'Failed to end current task.');
              // Server emits task_completed; UI handles via socket
            } catch (err) {
              alert(err.message || 'Error ending current task.');
            } finally {
              btn.disabled = false;
              btn.innerHTML = original;
            }
          });
        }
        if (elements.nextTaskBtn) {
          elements.nextTaskBtn.addEventListener('click', onNextTaskClick);
        }
      }

      // Leave Room Button
      if (elements.leaveRoomBtn) {
        elements.leaveRoomBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log(`Emitting leave_room for ${roomName}`);
          socket.emit('leave_room', { room: roomName, workshop_id: workshopId, user_id: userId });
          // Navigate after emitting (allow socket message to send)
          setTimeout(() => {
              window.location.href = elements.leaveRoomBtn.getAttribute('data-leave-url');
          }, 100); // Small delay
        });
      }
      // Leave room on unload
      window.addEventListener('beforeunload', () => {
          socket.emit('leave_room', { 
            room: roomName, 
            workshop_id: workshopId, 
            user_id: userId 
          });
      });

  // -- Begin Warm-Up Form --
    // Ensure the form exists before attaching the event listener
    if (elements.beginIntroForm) {
      elements.beginIntroForm.addEventListener('submit', async (e) => {
  console.log("Begin Warm-Up form submitted. Preventing default action.");
        e.preventDefault(); // Prevent default form submission

        const form = e.target;
        const button = form.querySelector('button[type="submit"]');
        if (!button) {
          console.error("Submit button not found in begin-intro-form");
          return; // Stop if button isn't found
        }

        button.disabled = true;
        button.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Starting...';

        try {
          const response = await fetch(form.action, {
            method: 'POST',
            headers: {
              'X-Requested-With': 'XMLHttpRequest', // Helps Flask detect AJAX
              'Accept': 'application/json'         // Indicate we prefer JSON response
            },
          });

          // Check if response is ok and content type is JSON before parsing
          const contentType = response.headers.get("content-type");
          if (response.ok && contentType && contentType.includes("application/json")) {
            const data = await response.json();
            if (data.success) {
              console.log("Workshop introduction POST successful. Waiting for socket event.");
            // SUCCESS: Stop the spinner and update button text
              button.innerHTML = 'Workshop Started'; // Update button text
              button.disabled = true; // Disable start button since workshop has started
              // TODO: Enable/disable other buttons based on workshop state
              // Best-effort: trigger facilitator TTS autoplay immediately if defaults allow and script already present
              try {
                const auto = !!((window.ttsDefaults && window.ttsDefaults.autoread));
                if (auto && window.FacilitatorTTS && window._lastTaskPayload) {
                  const p = window._lastTaskPayload;
                  const scriptText = (
                    p.tts_script || p.narration || p.summary_tts_script || p.script || p.instructions || ''
                  ).toString();
                  if (scriptText && scriptText.trim().length > 0) {
                    const tid = (p.task_id || window.currentTaskId);
                    if (tid) {
                      window.FacilitatorTTS.initForTask(tid, scriptText, (window.ttsDefaults||{}));
                      window.FacilitatorTTS.playSpeech();
                    }
                  }
                }
              } catch(_) {}
            } else {
              // Server returned JSON but indicated failure
              throw new Error(data.message || 'Failed to start warm-up (server error).');
            }
          } else if (!response.ok) {
            // Handle non-JSON errors (like 404, 500 without JSON body)
            const errorText = await response.text(); // Try to get error text
            console.error(`HTTP error ${response.status}: ${errorText}`);
            throw new Error(`HTTP error ${response.status}`);
          } else {
            // Handle unexpected success response that isn't JSON
            console.warn("Received non-JSON success response for begin_intro.");
            // Still rely on socket event, but log this oddity.
          }

        } catch (err) {
          console.error("Begin Warm-Up Error:", err);
          alert('Error starting workshop: ' + err.message);
          // Re-enable button ONLY on error
          button.disabled = false;
          button.innerHTML = 'Begin Workshop';
        }
        // NOTE: No 'finally' block to re-enable button here.
        // On success, the button should be hidden by the UI update
  // triggered by the 'warm_up_start' socket event.
      });
      console.log("Attached submit listener to #begin-intro-form"); // Confirm listener attachment
    } else {
      // Log if the form isn't found on page load (e.g., if user is not organizer)
      if (isOrganizer) { // Only log if organizer *should* see the button
        console.log("#begin-intro-form not found on page load, but expected for organizer.");
      }
    }

function onNextTaskClick(e) {
  e.preventDefault();
  const btn = elements.nextTaskBtn;
  if (!btn || btn.disabled) return;

  const originalHtml = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML =
    '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading…';

  fetch(`/workshop/${workshopId}/next_task`, {
    method: 'POST',
    headers: { 'X-Requested-With': 'XMLHttpRequest' }
  })
    .then(r => r.json().catch(() => ({})))
    .then(data => {
      if (!data || data.success !== true) {
        alert((data && data.message) || 'Failed to advance to next task.');
        btn.disabled = false;
        btn.innerHTML = originalHtml;
        return;
      }
      if (data.completed) {
        // Server indicates the workshop has completed; follow redirect if provided
        if (data.redirect_url) {
          window.location.href = data.redirect_url;
        } else {
          window.location.href = `/workshop/report/${workshopId}`;
        }
        return;
      }
      // on success we wait for task_ready from the server to restore the button
    })
    .catch(err => {
      alert(err.message || 'Network error.');
      btn.disabled = false;
      btn.innerHTML = originalHtml;
    });
}



      // ... (keep beforeunload listener) ...

      // --- Initial UI setup ---
      console.log("[ Init ] DOM Content Loaded. Initializing UI.");
      updateWorkshopStatusUI(workshopStatus);
      console.log(`[ Init ] Initial state: Task ID = ${currentTaskId}, Status = ${workshopStatus}`);
      // The join_room logic in sockets.py should emit necessary events (task, timer, whiteboard)
      // to populate the initial state if a task is already active.

      // Make Session Flow badges clickable for organizer to jump
  // Render plan and dynamic flow on load
  loadPlan();

    // Populate initial chat history for current scope without re-joining
    try { requestAndRenderChatHistory(window.currentChatScope || 'workshop_chat'); } catch(_) {}


    // Chat Form
    if (elements.chatForm) {
        elements.chatForm.addEventListener('submit', e => {
          e.preventDefault();
          const msg = elements.chatInput.value.trim();
          if (!msg) return;
          socket.emit('send_message', {
            room: roomName,
            message: msg,
            user_id: userId,
            workshop_id: workshopId,
            scope: (window.currentChatScope || 'workshop_chat')
          });
          elements.chatInput.value = '';
        });
    }

    // Initialize chat scope selector and reload history when changed (without re-joining the room)
    if (elements.chatScope) {
      try {
        elements.chatScope.value = (window.currentChatScope || 'workshop_chat');
      } catch(_) {}
      elements.chatScope.addEventListener('change', (e) => {
        const next = e.target.value || 'workshop_chat';
        window.currentChatScope = (next === 'discussion_chat') ? 'discussion_chat' : 'workshop_chat';
        try { sessionStorage.setItem(`ws:${workshopId}:chatFilter`, window.currentChatScope); } catch(_) {}
        // Fetch via GET to load history for the selected scope; live messages are filtered client-side
        try { requestAndRenderChatHistory(window.currentChatScope); } catch(_) {}
      });
    }

    // Sticky Right-Pane Tab: persist selected tab per-workshop in sessionStorage
    try {
      const tabKey = `ws:${workshopId}:paneTab`;
      const tabsEl = document.getElementById('rightTabs');
      if (tabsEl) {
        tabsEl.addEventListener('shown.bs.tab', (event) => {
          try {
            const btn = event.target; // newly shown tab button
            if (!btn) return;
            const id = btn.id || '';
            let value = 'transcript';
            if (id.includes('chat')) value = 'chat';
            else if (id.includes('participants')) value = 'participants';
            else if (id.includes('transcript')) value = 'transcript';
            sessionStorage.setItem(tabKey, value);
          } catch(_) {}
        });
        // Restore previously selected tab if present
        const savedTab = sessionStorage.getItem(tabKey);
        if (savedTab === 'chat' || savedTab === 'participants' || savedTab === 'transcript') {
          const btnId = savedTab === 'chat' ? 'chat-tab' : (savedTab === 'participants' ? 'participants-tab' : 'transcript-tab');
          const btn = document.getElementById(btnId);
          if (btn) {
            // Use Bootstrap Tab API if available; fallback to click
            try {
              const Tab = bootstrap.Tab || (bootstrap && bootstrap.Tab);
              if (Tab) {
                const inst = Tab.getOrCreateInstance(btn);
                inst.show();
              } else {
                btn.click();
              }
            } catch(_) { btn.click(); }
          }
        }
      }
    } catch(_) {}

      // --- Idea Submission Form Listener ---
      if (elements.ideaForm) {
          elements.ideaForm.addEventListener('submit', async (event) => {
              event.preventDefault(); // Prevent default form submission

              const ideaContent = elements.ideaInput.value.trim();
              if (!ideaContent || !currentTaskId || elements.ideaSubmitBtn.disabled) {
                  console.warn("Idea submission blocked (no content, no task, or disabled).");
                  return;
              }

              console.log(`Submitting idea for task ${currentTaskId}: "${ideaContent}"`);
              elements.ideaSubmitBtn.disabled = true;
              const originalButtonHtml = elements.ideaSubmitBtn.innerHTML;
              elements.ideaSubmitBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Submitting...';

              try {
                  const response = await fetch(`/workshop/${workshopId}/submit_idea`, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'X-Requested-With': 'XMLHttpRequest',
                          'Accept': 'application/json'
                      },
                      body: JSON.stringify({
                          task_id: currentTaskId,
                          content: ideaContent
                      })
                  });

                  const contentType = response.headers.get("content-type");
                  if (response.ok && contentType && contentType.includes("application/json")) {
                      const data = await response.json();
                      if (data.success) {
                          console.log("Idea submitted successfully via POST.");
                          elements.ideaInput.value = ''; // Clear input
                      } else {
                          throw new Error(data.message || `Idea submission failed.`);
                      }
                  } else if (!response.ok) {
                      const errorText = await response.text();
                      throw new Error(`HTTP error ${response.status}: ${errorText}`);
                  } else {
                      console.warn("Received non-JSON success response for submit_idea.");
                  }
              } catch (error) {
                  console.error('Error submitting idea:', error);
                  alert(`Error submitting idea: ${error.message}`);
              } finally {
                  // Re-enable button unless paused
                  if (workshopStatus !== 'paused') {
                      elements.ideaSubmitBtn.disabled = false;
                  }
                  elements.ideaSubmitBtn.innerHTML = originalButtonHtml; // Restore original text/icon
              }
          });
          console.log("Attached submit listener to #idea-form");
      } else {
          console.error("#idea-form not found on page load.");
      }



  // --- Initial UI setup (second call removed to avoid duplicates) ---
  }); // End DOMContentLoaded

  // Deprecated helpers removed; dynamic flow uses exact indices

  // Receive setting updates from server and reflect immediately
  socket.on('auto_advance_update', (data) => {
    if (!data || data.workshop_id !== workshopId) return;
    autoAdvanceEnabled = !!data.enabled;
    autoAdvanceDelaySeconds = Math.max(0, parseInt(data.after_seconds || 0, 10) || 0);
    if (isOrganizer) {
      const sw = document.getElementById('auto-advance-switch');
      const sec = document.getElementById('auto-advance-seconds');
      if (sw) sw.checked = autoAdvanceEnabled;
      if (sec) sec.value = String(autoAdvanceDelaySeconds);
    }
    // Toast
    const area = document.getElementById('notification-area');
    if (area) {
      const div = document.createElement('div');
      div.className = 'alert alert-secondary alert-dismissible fade show shadow-sm';
      div.role = 'alert';
      div.innerHTML = `Auto-advance ${autoAdvanceEnabled ? 'enabled' : 'disabled'}${autoAdvanceEnabled ? ` (${autoAdvanceDelaySeconds}s)` : ''}.
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
      area.appendChild(div);
      setTimeout(() => { const inst = bootstrap.Alert.getOrCreateInstance(div); inst.close(); }, 4000);
    }
  });

  // --- Transcript Persistence Loader (existing lines before refresh) ---
  async function loadExistingTranscripts() {
    try {
      const resp = await fetch(`/workshop/${workshopId}/transcripts`, { headers: { 'X-Requested-With': 'XMLHttpRequest' }});
      if (!resp.ok) return; // ignore silently
      const data = await resp.json();
      if (!data || !Array.isArray(data.transcripts)) return;
      const list = document.getElementById('transcript-list');
      if (!list) return;
      if (data.transcripts.length > 0) {
        const ph = document.getElementById('transcript-empty-placeholder');
        if (ph) ph.remove();
      }
      // Avoid duplicates across multiple loads
      window.__loadedTranscriptIds = window.__loadedTranscriptIds || new Set();
      data.transcripts.forEach(t => {
        if (window.__loadedTranscriptIds.has(t.transcript_id)) return;
        renderPersistedTranscript(t);
        window.__loadedTranscriptIds.add(t.transcript_id);
      });
      const statusEl = document.getElementById('transcript-status');
      if (statusEl) {
        const c = data.transcripts.length;
        statusEl.textContent = c > 0 ? `CC: ${c} line${c===1?'':'s'}` : 'CC: Off';
      }
    } catch (e) {
      console.warn('Transcript preload failed', e);
    }
  }

  // GET-based chat history fetch/render for current scope
  async function requestAndRenderChatHistory(scope) {
    try {
      const sc = (scope === 'discussion_chat') ? 'discussion_chat' : 'workshop_chat';
      const r = await fetch(`/workshop/${workshopId}/chat?scope=${encodeURIComponent(sc)}`, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      const d = await r.json().catch(() => ({}));
      if (!r.ok || !d || !Array.isArray(d.messages)) return;
      if (!elements.chatMessages) return;
      elements.chatMessages.innerHTML = '';
      d.messages.forEach(msg => appendChatMessage(msg.user_name, msg.message, msg.timestamp, true, msg.message_type || 'user'));
      elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    } catch (_) { /* ignore */ }
  }

  function renderPersistedTranscript(t) {
    const list = document.getElementById('transcript-list');
    if (!list) return;
    const wrapper = document.createElement('div');
    const isFacilitator = (t.entry_type === 'facilitator');
    wrapper.className = 'transcript-final mb-2' + (isFacilitator ? ' facilitator' : '');
    // Carry identifiers for polish endpoint
    wrapper.dataset.transcriptId = t.transcript_id;
    wrapper.dataset.workshopId = String(workshopId);
    if (typeof t.user_id !== 'undefined' && t.user_id !== null) {
      wrapper.dataset.userId = String(t.user_id);
    }
    wrapper.dataset.entryType = t.entry_type || (isFacilitator ? 'facilitator' : 'human');
    const tsRaw = t.start_timestamp || t.created_timestamp;
    const ts = tsRaw ? new Date(tsRaw) : new Date();
    const timeStr = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  const name = (t.entry_type === 'facilitator') ? 'AI Facilitator' : ([(t.first_name||''),(t.last_name||'')].join(' ').trim() || 'Speaker');
    const rawText = (t.raw_text || t.text || '').toString();
    const processedText = (t.processed_text || '').toString();
    const wasPolished = !!t.was_polished && processedText.trim().length > 0;
    const safeRaw = rawText.replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const safeProcessed = processedText.replace(/</g,'&lt;').replace(/>/g,'&gt;');
    // Mirror the live appendFinal markup so controls exist after refresh
  const currentUserId = (typeof userId !== 'undefined') ? Number(userId) : (typeof window !== 'undefined' && typeof window.userId !== 'undefined' ? Number(window.userId) : null);
  const ownerUserId = (typeof t.user_id !== 'undefined' && t.user_id !== null) ? Number(t.user_id) : null;
  const participantDeleteToggle = participantDeleteEnabled;
  const ownerCanDelete = participantDeleteToggle && !isFacilitator && ownerUserId !== null && currentUserId !== null && ownerUserId === currentUserId;
  const canDelete = !!t.transcript_id && (isOrganizer || ownerCanDelete);
    wrapper.innerHTML = `
      <div class="d-flex align-items-start gap-2">
        <div class="flex-grow-1">
          <div class="d-flex justify-content-between align-items-center">
            <strong class="small">${isFacilitator ? '<i class="bi bi-robot me-1 text-primary"></i>' : ''}${name}</strong>
            <span class="text-muted small">${timeStr}</span>
          </div>
          <div class="small transcript-text">
            <span class="text-original ${wasPolished ? 'd-none' : ''}">${safeRaw}</span>
            <span class="text-processed ${wasPolished ? '' : 'd-none'}">${wasPolished ? safeProcessed : ''}</span>
          </div>
          <div class="d-flex align-items-center gap-2 mt-1">
            <button class="btn btn-sm btn-outline-secondary polish-btn"><i class="bi bi-magic"></i> ${wasPolished ? 'Re-polish' : 'Polish'}</button>
            <div class="btn-group btn-group-sm toggle-group ${wasPolished ? '' : 'd-none'}">
              <button class="btn btn-outline-secondary show-original ${wasPolished ? '' : 'active'}">Original</button>
              <button class="btn btn-outline-secondary show-processed ${wasPolished ? 'active' : ''}">Corrected</button>
            </div>
            <span class="spinner-border spinner-border-sm text-secondary ms-1 d-none" role="status"></span>
            ${canDelete ? '<button type="button" class="btn btn-sm btn-outline-danger delete-transcript-btn ms-auto"><i class="bi bi-trash"></i> Delete</button>' : ''}
          </div>
        </div>
      </div>`;
    list.appendChild(wrapper);
    // Disable polish action for synthetic entries (no transcript_id)
    try {
      if (!t.transcript_id || isFacilitator) {
        const pb = wrapper.querySelector('.polish-btn');
        if (pb) { pb.disabled = true; pb.title = 'Not editable'; }
      }
    } catch (_) {}
    list.scrollTop = list.scrollHeight;
  }

</script>
<script src="/static/js/forum.js"></script>
{# --- Load the Assistant Chat Interface --- #}
{% include 'assistant.html' %}
<script src="/static/js/transcription.js"></script>
<script>
  // Expose identifiers & conference feature flags for embedded view
  window.workshopId = JSON.parse('{{ workshop.id | tojson | safe }}');
  window.userId = JSON.parse('{{ current_user.user_id | tojson | safe }}');
  window.conferenceFlags = {
    conferenceActive: JSON.parse('{{ workshop.conference_active | tojson | safe }}'),
    transcriptionEnabled: JSON.parse('{{ workshop.transcription_enabled | tojson | safe }}')
  };
</script>
<script src="{{ url_for('static', filename='js/videoConference.js') }}"></script>
<script src="{{ url_for('static', filename='js/facilitatorTTS.js') }}"></script>
<script src="{{ url_for('static', filename='js/tts.js') }}"></script>
<script src="{{ url_for('static', filename='js/resultsViewer.js') }}"></script>
<script>
  // Kick off transcript preload after global IDs defined
  document.addEventListener('DOMContentLoaded', () => { try { loadExistingTranscripts(); } catch(e) { console.warn(e); } });
</script>
<script>
  // TTS bindings for workshop room
  document.addEventListener('DOMContentLoaded', () => {
    // Auto-start the video conference if enabled, as soon as DOM is ready
    try { ensureConferenceAutoStartIfEnabled(); } catch(_) {}
    // Facilitator UI binding
    try {
      if (window.FacilitatorTTS) {
        window.FacilitatorTTS.bindUI({
          playBtn: document.getElementById('fac-tts-play'),
          pauseBtn: document.getElementById('fac-tts-pause'),
          stopBtn: document.getElementById('fac-tts-stop'),
          replayBtn: document.getElementById('fac-tts-replay'),
          progressBar: document.getElementById('fac-tts-progress'),
          progressContainer: document.getElementById('fac-tts-progress-container'),
          elapsed: document.getElementById('fac-tts-elapsed'),
          duration: document.getElementById('fac-tts-duration'),
          icon: document.getElementById('facilitator-voice-icon'),
          settings: {
            providerSel: document.getElementById('fac-tts-provider'),
            voiceInput: document.getElementById('fac-tts-voice'),
            speedInput: document.getElementById('fac-tts-speed'),
            saveBtn: document.getElementById('fac-tts-save'),
            cancelBtn: document.getElementById('fac-tts-cancel')
          }
        });
      }
    } catch(_) {}
    // --- Helpers: Build clean transcript text (first name + content, no timestamps) ---
    function selectionRanges() {
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0 || sel.isCollapsed) return [];
      const arr = [];
      for (let i = 0; i < sel.rangeCount; i++) arr.push(sel.getRangeAt(i));
      return arr;
    }

    function rangeIntersectsNode(range, node) {
      if (range.intersectsNode) return range.intersectsNode(node);
      // Fallback: create a node range to compare
      const nodeRange = document.createRange();
      try {
        nodeRange.selectNode(node);
      } catch (_) {
        try { nodeRange.selectNodeContents(node); } catch (_) { return false; }
      }
      return !(range.compareBoundaryPoints(Range.END_TO_START, nodeRange) <= 0 ||
               range.compareBoundaryPoints(Range.START_TO_END, nodeRange) >= 0);
    }

    function transcriptEntriesWithin(rootEl, ranges) {
      const selector = '.transcript-final, .transcript-live';
      const all = Array.from(rootEl.querySelectorAll(selector));
      if (!ranges || ranges.length === 0) return all;
      return all.filter(node => ranges.some(r => rangeIntersectsNode(r, node)));
    }

    function extractEntryText(entry) {
      // Expected structure from renderPersistedTranscript():
      // <div class="flex-grow-1">
      //   <div class="d-flex ...">
      //     <strong class="small">Full Name</strong>
      //     <span class="text-muted small">Time</span>
      //   </div>
      //   <div class="small transcript-text">
      //     <span class="text-original">...</span>
      //     <span class="text-processed d-none">...</span>
      //   </div>
      // </div>
      // We must read ONLY the currently visible text (respecting toggles), not both.
      const container = entry.querySelector('.flex-grow-1');
      if (!container) return '';
      const textBlock = container.querySelector('.transcript-text');
      let contentText = '';
      if (textBlock) {
        // Find the first visible span inside transcript-text
        const spans = Array.from(textBlock.querySelectorAll('.text-original, .text-processed'));
        const visible = spans.find(sp => !sp.classList.contains('d-none') && (sp.textContent || '').trim().length > 0);
        if (visible) {
          // Use innerText when available to respect CSS visibility; fallback to textContent
          contentText = (visible.innerText || visible.textContent || '').trim();
        } else {
          // Fallback: use innerText of the textBlock (respects display:none) to avoid reading hidden copy
          contentText = ((textBlock.innerText || '').trim()) || (textBlock.textContent || '').trim();
        }
      } else {
        // Legacy/fallback: last non-muted .small anywhere inside the container
        const candidates = Array.from(container.querySelectorAll('.small')).filter(el => !el.classList.contains('text-muted'));
        if (candidates.length) {
          const last = candidates[candidates.length - 1];
          contentText = (last.innerText || last.textContent || '').trim();
        }
      }
      return contentText || '';
    }

    function composeTranscriptText(listEl) {
      // Always read the full transcript (ignore selection)
      const entries = transcriptEntriesWithin(listEl, null);
      const lines = entries.map(extractEntryText).filter(Boolean);
      return lines.join('\n');
    }
    // Parse workshop defaults embedded as JSON
    (function(){
      const el = document.getElementById('tts-defaults-json');
      try {
        window.ttsDefaults = el ? JSON.parse(el.textContent || '{}') : {};
      } catch(_) { window.ttsDefaults = {}; }
    })();
    const ttsDisp = document.getElementById('tts-defaults-display');
    if (ttsDisp) {
      const v = window.ttsDefaults.voice;
      const p = window.ttsDefaults.provider;
      const s = window.ttsDefaults.speed;
      //ttsDisp.textContent = `TTS: ${p}${v?` · ${v}`:''}${(s&&s!==1)?` · ${s}x`:''}`;
    }

    // Old Speaker/Stop controls removed
    const btnTranscript = document.getElementById('btn-tts-read-transcript');
    if (btnTranscript) {
      btnTranscript.addEventListener('click', () => {
        const list = document.getElementById('transcript-list');
        if (!list) return;
        // Read selection if present; otherwise read all, with cleaner output (no timestamps)
        const text = composeTranscriptText(list);
        if (window.TTS) {
          window.TTS.play(text);
        }
      });
    }

    // Stop buttons: halt any ongoing playback and clear queue
    // Old task stop button removed
    const btnStopTranscript = document.getElementById('btn-tts-stop-transcript');
    if (btnStopTranscript) {
      btnStopTranscript.addEventListener('click', () => {
        try { if (window.TTS && typeof window.TTS.stop === 'function') window.TTS.stop(); } catch (_) {}
      });
    }
  });
</script>
<style>
  .facilitator-voice-icon { width:14px; height:14px; border-radius:50%; background:#6c757d; box-shadow:0 0 0 0 rgba(13,110,253,0.7); transition:background .2s ease; }
  .facilitator-voice-icon.speaking { background:#0d6efd; animation: fac-pulse 1.2s infinite; }
  @keyframes fac-pulse { 0% { box-shadow:0 0 0 0 rgba(13,110,253,0.7);} 70% { box-shadow:0 0 0 8px rgba(13,110,253,0); } 100% { box-shadow:0 0 0 0 rgba(13,110,253,0); } }
  .progress-thin { height: 6px; }
  .fac-tts-progress-container { min-width: 220px; cursor: pointer; }
  .fac-tts-settings-menu { min-width: 260px; }
  /* Facilitator transcript styling */
  .transcript-final.facilitator { background: #f0f7ff; border-left: 3px solid #0d6efd; border-radius: 4px; padding: 6px 8px; }
  .transcript-final.facilitator .polish-btn { pointer-events: none; opacity: 0.6; }
  .sticky-note.ai-sticky-note { background: #e7f5ff; border-color: rgba(13,110,253,0.25); }
  .sticky-note.ai-sticky-note strong { color: #0d6efd; }
  .sticky-note.ai-sticky-note.ai-sticky-excluded { opacity: 0.55; border-style: dashed; }
  .sticky-note .ai-idea-excluded-note { color: var(--bs-secondary-color); }
  /* Speech large preview */
  .speech-spotlight-box { position: relative; border: 1px solid var(--bs-border-color); border-radius: .5rem; background: #f8f9fa; overflow: hidden; }
  .speech-spotlight-box .speech-video-wrap { position: relative; width: 100%; height: 320px; background: #000; display:flex; align-items:center; justify-content:center; }
  @media (min-width: 1200px) { .speech-spotlight-box .speech-video-wrap { height: 380px; } }
  .speech-spotlight-box .speech-video-placeholder { position: absolute; color: #adb5bd; }
  .speech-spotlight-box.ready { background: #000; }
  .summary-experience { position: relative; overflow: hidden; }
  .summary-experience__glow { position: absolute; inset: -40% -20% auto; height: 320px; background: radial-gradient(circle at 20% 20%, rgba(13,110,253,0.25), transparent 55%); pointer-events: none; opacity: 0.8; }
  .summary-experience .card-body { position: relative; z-index: 1; }
  .summary-insights__cards { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
  .summary-metric { background: rgba(255,255,255,0.6); -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); border: 1px solid rgba(13,110,253,0.08); border-radius: 1rem; padding: 1rem 1.25rem; box-shadow: inset 0 1px 0 rgba(255,255,255,0.65); }
  .summary-metric__value { font-size: 1.75rem; font-weight: 700; letter-spacing: -0.02em; }
  .summary-metric__value--primary { color: #0d6efd; }
  .summary-metric__value--success { color: #198754; }
  .summary-metric__value--warning { color: #d97706; }
  .summary-metric__value--info { color: #0dcaf0; }
  .summary-metric__value--secondary { color: #6c757d; }
  .summary-metric__label { font-weight: 600; }
  .summary-tabs .nav-link { font-weight: 500; border-radius: 999px; padding-inline: 1.25rem; }
  .summary-pane { background: rgba(255,255,255,0.82); border: 1px solid rgba(13,110,253,0.08); border-radius: 1rem; padding: 1.5rem; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
  .summary-markdown { font-size: 0.95rem; line-height: 1.6; }
  .summary-markdown h1, .summary-markdown h2, .summary-markdown h3 { margin-top: 1.5rem; font-weight: 700; }
  .summary-markdown h1:first-child, .summary-markdown h2:first-child, .summary-markdown h3:first-child { margin-top: 0; }
  .summary-markdown ul { padding-left: 1.2rem; }
  .summary-pdf-viewer { min-height: 320px; display: flex; align-items: center; justify-content: center; }
  .summary-empty-state { text-align: center; }
  .summary-slides { min-height: 200px; }
  .summary-slide-grid { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); }
  .summary-slide-card { border: 1px solid rgba(108,117,125,0.25); border-radius: 0.85rem; padding: 1rem; background: rgba(255,255,255,0.9); position: relative; overflow: hidden; }
  .summary-slide-card::after { content: ""; position: absolute; inset: auto -40% -60% -40%; height: 120px; background: radial-gradient(circle at 50% 50%, rgba(13,110,253,0.08), transparent 70%); }
  .summary-slide-index { position: absolute; top: 0.75rem; right: 1rem; font-size: 0.85rem; font-weight: 600; color: #0d6efd; opacity: 0.8; }
  .summary-slide-title { font-weight: 600; margin-bottom: 0.35rem; padding-right: 2rem; }
  .summary-slide-bullets { margin-bottom: 0; padding-left: 1rem; font-size: 0.9rem; }
  .summary-slide-bullets li + li { margin-top: 0.35rem; }
  .summary-slide-table { font-weight: 600; }
  .summary-session-timeline { display: grid; gap: 1rem; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
  .summary-session-timeline__item { border: 1px solid rgba(108,117,125,0.25); border-radius: 1rem; padding: 1rem 1.25rem; background: rgba(248,249,250,0.75); -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); }
  .summary-session-timeline__phase { font-weight: 600; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.08em; color: #0d6efd; }
  .summary-session-timeline__status { font-weight: 600; margin-top: 0.35rem; }
  .summary-session-timeline__status.is-active { color: #198754; }
  .summary-session-timeline__detail { margin-top: 0.4rem; }
  .summary-json-dump { margin-top: 1.5rem; }
  .summary-json-pre { max-height: 280px; overflow: auto; font-size: 0.8rem; background: #0f172a; color: rgba(248,250,252,0.88); border-radius: 0.75rem; padding: 1rem; }
  .summary-top-clusters .summary-cluster-card { background: rgba(255,255,255,0.9); border-color: rgba(13,110,253,0.08); box-shadow: inset 0 1px 0 rgba(255,255,255,0.5); }
  .summary-cluster-score { color: #0d6efd; }
  .summary-insights__pulse { flex-wrap: wrap; }
  .summary-pulse { font-size: 0.85rem; font-weight: 500; color: #0d6efd; background: rgba(13,110,253,0.08); border-radius: 999px; padding: 0.5rem 0.9rem; }
  .summary-artifact-actions .btn + .btn { margin-left: 0.5rem; }
  @media (max-width: 576px) {
    .summary-experience .card-body { padding: 1.75rem; }
    .summary-insights__cards { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
    .summary-slide-grid { grid-template-columns: 1fr; }
  }
</style>
{% endblock %}
